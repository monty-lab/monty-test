---
layout: post
title: Cmu15445Project#0
date: 2023-10-29 16:39 +0800
categories: [cmu15445]
tags: [cmu15445, C++, 智能指针, Copy-On-Write]
toc:  true
---

## 项目规范：
实现一个支持key-value存储的copy-on-write trie，trie是用于检索给定键的值的高效有序树数据结构。为了简化解释，假设键是可变长度的字符串，实际上它们可以是任意类型。
trie中的每个节点可以有多个子节点，表示不同的可能下一个字符。
实现的key-value存储可以存储映射到任何类型的值的字符串键。键的值存储在表示该键的最后一个字符的节点（也称为终端节点）中。例如，考虑将 key-value对插入trie。("ab", 1) ("ac", "val")

<center><img src="/assets/img/cmu_trie_0.svg" width="25%"></center>

## Task #1 Copy-On-Write Trie
修改trie.h 和 trie.cpp实现Copy-On-Write Trie，操作不会直接修改原始 trie 的节点。相反，将为修改后的数据创建新节点，并为新修改的 trie 返回新的根。考虑在上面的示例中插入("ad", 2)，通过重用原始树中的两个子节点创建一个新的 Node2 。然后插入("b", 3)，如下图所示。

<center><img src="/assets/img/cmu_trie_1.svg" width="50%"></center>

trie 应该支持 3 个操作：

- Get(key)：获取key对应的value。
- Put(key, value)：给key设置对应的值。如果键已存在，则覆盖现有值。值的类型可能是不可复制的（即std::unique_ptr<int>）。该方法返回一个新的字典树。
- Delete(key)：删除键的值。该方法返回一个新的字典树。

这些操作都不应该直接在 trie 本身上执行。您应该创建新的 trie 节点并尽可能重用现有的节点。

要创建新节点，应该使用类TrieNode的Clone函数。要在新的 trie 中重用现有节点，可以复制std::shared_ptr<TrieNode>：复制共享指针不会复制基础数据。不应该在该项目中使用 new 和 delete

## 代码实践

### Trie头文件

```cpp
// TrieNode
class TrieNode {
 public:
  TrieNode() = default;
  explicit TrieNode(std::map<char, std::shared_ptr<const TrieNode>> children) : children_(std::move(children)) {}
  virtual ~TrieNode() = default;
  virtual auto Clone() const -> std::unique_ptr<TrieNode> { return std::make_unique<TrieNode>(children_); }
  // 树子节点的map
  std::map<char, std::shared_ptr<const TrieNode>> children_;
  // 是否叶子节点
  bool is_value_node_{false};
};

// TrieNodeWithValue 
template <class T>
class TrieNodeWithValue : public TrieNode {
 public:
  explicit TrieNodeWithValue(std::shared_ptr<T> value) : value_(std::move(value)) { this->is_value_node_ = true; }
  TrieNodeWithValue(std::map<char, std::shared_ptr<const TrieNode>> children, std::shared_ptr<T> value)
      : TrieNode(std::move(children)), value_(std::move(value)) {
    this->is_value_node_ = true;
  }

  auto Clone() const -> std::unique_ptr<TrieNode> override {
    return std::make_unique<TrieNodeWithValue<T>>(children_, value_);
  }
  std::shared_ptr<T> value_;
};

// Trie
class Trie {
 private:
  std::shared_ptr<const TrieNode> root_{nullptr};
  explicit Trie(std::shared_ptr<const TrieNode> root) : root_(std::move(root)) {}

 public:
  Trie() = default;

  template <class T>
  auto Get(std::string_view key) const -> const T *;

  template <class T>
  auto Put(std::string_view key, T value) const -> Trie;

  auto Remove(std::string_view key) const -> Trie;
};
```

### Task #1