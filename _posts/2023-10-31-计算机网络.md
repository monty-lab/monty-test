---
layout: post
title: 计算机网络
date: 2023-10-31 08:35 +0800
categories: [笔记]
tags: [计算机网络]
toc:  true
---

# 计算机网络

![](/assets/img/tcp_ip_struct.png)

## 1 路由

IP 数据包头部

![](/assets/img/ip_header.png)

路由可分为静态和动态路由。静态路由由管理员手动维护；动态路由由路由协议自动维护。两种主要算法：距离向量法（Distance Vector Routing）和链路状态算法（Link-State Routing）。

RIP 路由协议：采用距离向量算法，即路由器根据距离选择路由。 路由器收集所有可到达目的地的不同路径，并且保存有关到达每个目的地的最少站点数的路径信息。同时路由器也把所收集的路由信息用RIP协议通知**相邻**的其它路由器。RIP只适用于小型的同构网络，因为它允许的最大站点数为15，任何超过15个站点的目的地均被标记为不可达。而且RIP每隔30s一次的路由信息广播也是造成网络的广播风暴的重要原因之一。

OSPF 路由协议：基于链路状态的路由协议，需要每个路由器向其同一管理域的所有其它路由器发送链路状态广播信息。在OSPF的链路状态广播中包括所有接口信息、所有的量度和其它一些变量。利用OSPF的路由器首先必须收集有关的链路状态信息，并根据一定的算法计算出到每个节点的最短路径。OSPF将一个自治域再划分为区，区内路由选择；区间路由选择。大大减少了网络开销，并增加了网络的稳定性。

BGP 和 BGP4 路由协议：BGP 是为 TCP／IP 互联网设计的外部网关协议，用于多个自治域之间。

**域名解析：**

![](/assets/img/dns.png)

（1）先到浏览器的DNS缓存中查询是否有对应记录，如有则直接返回ip地址，如果没有则下一步

（2）接着会进行一个判断：软件是否或浏览器是否进行域名直接查询。如果有的话，会直接连到软件服务商提供的DNS服务器上，返回IP；如果没有，则继续查询操作系统的缓存：如有则直接返回ip地址，完成解析，如果没有则下一步

（3）最后查看本地host文件

（4）使用本地DNS服务器，缓存服务器有2种，一种是公共DNS服务器Google DNS（8.8.8.8）；另一种是本地运营商提供的DNS服务器；如果缓存服务器无法找到对应IP，则会把信息传递给递归服务器。

（5）当信息传递给递归服务器后，会根据内置的根域名服务器ip地址，寻求根域名服务器的帮助

从客户端到本地DNS服务器是属于递归查询（函数栈调用递归），而DNS服务器之间就是的交互查询就是迭代查询。

修改本机host来**干预域名解析**，在/etc/hosts

**DNS劫持**就是通过劫持了DNS服务器，通过某些手段取得某域名的解析记录控制权，进而修改此域名的解析结果

**网关**即网络中的关卡，我们的互联网是一个一个的局域网、城域网、等连接起来的，在连接点上就是一个一个网络的关卡，即我们的网关，他是保证网络互连的，翻译和转换，使得不同的网络体系能够进行。

**网内通信**，即通信双方都位处同一网段中，数据传输无需经过路由器(或三层交换机)，即可由本网段自主完成。假设发送主机的**ARP（Address Resolution Protocol：地址解析协议）** 表中并无目的主机对应的表项，则发送主机会以目的主机IP地址为内容，广播ARP请求以期获知目的主机MAC地址，并通过交换机(除到达端口之外的所有端口发送，即洪泛(Flooding))向全网段主机转发，而只有目的主机接收到此ARP请求后会将自己的MAC地址和IP地址装入ARP应答后将其回复给发送主机。之后即可向目的主机发送数据，将待发送数据封装成帧

CSRF全称叫做跨站请求伪造。

- 登录受信任网站A，并在本地生成Cookie。
- 在不登出A的情况下，访问危险网站B。黑客就可以获取你的cookie。
- 网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A；
- 浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。

1）请求头中的Referer验证（不推荐）HTTP的头部有一个Referer信息的字段，它记录着该次HTTP请求的来源地址（即它从哪里来的）,既然CSRF攻击是伪造请求是从服务器发送过来的，那么我们就禁止跨域访问，在服务器端增加验证，过滤掉那些不是从本服务器发出的请求，这样可以在一定程度上避免CSRF攻击。 但是这也有缺点，比如如果是从搜索引擎所搜结果调整过来，请求也会被认为是跨域请求。

2）请求令牌验证（token验证）token验证是一种比较广泛使用的防止CSRF攻击的手段，当用户通过正常渠道访问服务器时，服务器会生成一个随机的字符串保存在session中，并作为令牌（token）返回给客户端，以隐藏的形式保存在客户端中，客户端每次请求都会带着这个token，服务器根据该token判断该请求是否合法

## 2 TCP

TCP 头部

![image.png](/assets/img/tcp_header.png)

![image.png](/assets/img/tcp_3.png)

**TCP 2次握手：**为了实现可靠数据传输，TCP 协议的通信双方，都必须维护一个序列号，以标识发送出去的数据包中，哪些是已经被对方收到的。三次握手的过程即是**通信双方相互告知序列号起始值，并确认对方已经收到了序列号起始值**的必经步骤

如果第一次握手消息丢失，那么请求方不会得到ack消息，**超时后进行重传 SYN 报文**

如果第二次握手消息丢失，那么请求方不会得到ack消息，**超时后进行重传 SYN 报文**；服务器端收不到第三次握手，于是**服务端这边会触发超时重传机制，重传 SYN-ACK 报文**。

如果第三次握手消息丢失，服务端那一方收不到确认报文，就会触发超时重传机制，重传 SYN-ACK 报文，直到收到第三次握手，或者达到最大重传次数。

在 Linux 里，客户端的 SYN 报文最大重传次数由 tcp_syn_retries（tcp_synack_retries）内核参数控制，这个参数是可以自定义的，默认值一般是 5。第一次超时重传是在 1 秒后，第二次超时重传是在 2 秒，第三次超时重传是在 4 秒后，第四次超时重传是在 8 秒后，第五次是在超时重传 16 秒后。

SYN Flood是一种利用TCP协议缺陷，发送大量伪造的TCP连接请求，使被攻击方资源耗尽（CPU满负荷或内存不足)的攻击方式。从互联网服务提供商(ISP)购买服务；使用入侵防御系统/防火墙技术保留在内部并自己解决；使用内容分发网络(CDN)。

![image.png](/assets/img/tcp_4.png)

最大生存时间MSL（Maximum Segment Lifetime），它是任何报文段被丢弃前在网络内的最长时间。

TIME_WAIT：当TCP的一端发起主动关闭，在发出最后一个ACK包后，即第3次握手完成后发送了第四次握手的ACK包后就进入了TIME_WAIT状态，必须在此状态上停留两倍的MSL时间，等待2MSL时间主要目的是怕最后一个ACK包对方没收到，那么对方在超时后将重发第三次握手的FIN包，主动关闭端接到重发的FIN包后可以再发一个ACK应答包。在TIME_WAIT状态时两端的端口不能使用，要等到2MSL时间结束才可继续使用。

**TCP可靠性保证：TCP主要提供了检验和、序列号/确认应答、超时重传、最大消息长度、滑动窗口控制等方法实现了可靠性传输。**

**检验和：** 把伪首部、TCP报头、TCP数据分为16位的字，如果总长度为奇数个字节，则在最后增添一个位都为0的字节。把TCP报头中的校验和字段置为0。用反码相加法累加所有的16位字（进位也要累加）。对计算结果取反，作为TCP的校验和。将所有原码相加，高位叠加，全为1则正确

**序列号/确认应答：** 确认包（ACK包）

**TCP 超时重传：** TCP可靠性中最重要的一个机制是处理数据超时和重传。TCP协议要求在发送端每发送一个报文段，就启动一个定时器并等待确认信息；接收端成功接收新数据后返回确认信息。若在定时器超时前数据未能被确认，TCP就认为报文段中的数据已丢失或损坏，需要对报文段中的数据重新组织和重传。

**最大消息长度：** 在建立TCP连接的时候，双方约定一个最大的长度（MSS）作为发送的单位，重传的时候也是以这个单位来进行重传。

**滑动窗口控制：** 窗口的大小就是在无需等待确认包的情况下，发送端还能发送的最大数据量。这个机制的实现就是使用了大量的缓冲区，通过对多个段进行确认应答的功能。是传输层进行流控的一种措施，接收方通过通告发送方自己的窗口大小，从而控制发送方的发送速度，从而达到防止发送方发送速度过快而导致自己被淹没的目的。

**TCP拥塞控制：**

RTT(Round Trip Time)：一个连接的往返时间，即数据发送时刻到接收到确认的时刻的差值；

![](/assets/img/tcp_traffic_control.png)

慢开始：初始发送方拥塞窗口cwnd的值为1，接收方收到数据报文段后，给发送方回复一个确认报文段，发送方每次收到一个确认报文就将拥塞窗口的值加1。

拥塞避免：当前的拥塞窗口cwnd的值已经等于慢开始门限值，之后改用拥塞避免算法。每个传输轮次，拥塞窗口cwnd只能线性加一

快重传：当发送方连续收到三个重复的ACK报文时，直接重传对方尚未收到的报文段，而不必等待那个报文段设置的重传计时器超时

快恢复：发送端收到连续三个冗余ACK（即重复确认）时，把慢开始门限ssthresh设置为出现拥塞时发送方cwnd的一半。把cwnd的值设置为慢开始门限ssthresh改变后的数值，然后开始执行拥塞避免算法，使拥塞窗口缓慢地线性增大。

TCP粘包和拆包：一个完整的包可能会被TCP拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送，这就是所谓的TCP粘包和拆包问题。

**HTTP Keep-Alive和TCP Keep-Alive区别：**

1. **HTTP Keep-Alive**在http早期，每个http请求都要求打开一个tpc socket连接，并且使用一次之后就断开这个tcp连接。使用keep-alive可以改善这种状态，即在一次TCP连接中可以持续发送多份数据而不会断开连接。通过使用keep-alive机制，可以减少tcp连接建立次数，也意味着可以减少TIME_WAIT状态连接，以此提高性能和提高httpd服务器的吞吐率(更少的tcp连接意味着更少的系统内核调用,socket的accept()和close()调用)。但是，keep-alive并不是免费的午餐,长时间的tcp连接容易导致系统资源无效占用。配置不当的keep-alive，有时比重复利用连接带来的损失还更大。所以，正确地设置keep-alive timeout时间非常重要。
2. **TCP KEEPALIVE**链接建立之后，如果应用程序或者上层协议一直不发送数据，或者隔很长时间才发送一次数据，当链接很久没有数据报文传输时如何去确定对方还在线，到底是掉线了还是确实没有数据传输，链接还需不需要保持，这种情况在TCP协议设计中是需要考虑到的。TCP协议通过一种巧妙的方式去解决这个问题，当超过一段时间之后，TCP自动发送一个数据为空的报文给对方，如果对方回应了这个报文，说明对方还在线，链接可以继续保持，如果对方没有报文返回，并且重试了多次之后则认为链接丢失，没有必要保持链接。
3. TCP的keepalive机制和HTTP的keep-alive机制是说的完全不同的两个东西，tcp的keepalive是在ESTABLISH状态的时候，双方如何检测连接的可用行。而http的keep-alive说的是如何避免进行重复的TCP三次握手和四次挥手的环节。

TCP延迟ACK和累积应答：TCP在接收到对端的报文后，并不会立即发送ack，而是等待一段时间发送ack，以便将ack和要发送的数据一块发送。

## 3 UDP

UDP仅提供了最基本的数据传输功能，至于传输时连接的建立和断开、传输可靠性的保证这些UDP统统不关心，而是把这些问题抛给了UDP上层的应用层程序去处理。可以在应用层模仿传输层TCP的可靠性传输

TCP和UDP：

1. TCP协议是有连接的，有连接的意思是开始传输实际数据之前TCP的客户端和服务器端必须通过三次握手建立连接，会话结束之后也要结束连接。而UDP是无连接的
2. TCP协议保证数据按序发送，按序到达，提供超时重传来保证可靠性，但是UDP不保证按序到达，甚至不保证到达，只是努力交付，即便是按序发送的序列，也不保证按序送到。
3. TCP协议所需资源多，TCP首部需20个字节（不算可选项），UDP首部字段只需8个字节。
4. TCP有流量控制和拥塞控制，UDP没有，网络拥堵不会影响发送端的发送速率TCP是一对一的连接，而UDP则可以支持一对一，多对多，一对多的通信。
5. TCP面向的是字节流的服务，UDP面向的是报文的服务。
6. 上层使用的协议；基于TCP协议的：Telnet，FTP以及SMTP协议。基于UDP协议的：DHCP、DNS、SNMP、TFTP、BOOTP。

应用场景：TCP用于电子邮件、文件传输、telnet；UDP用于视频通话、实时游戏等。

## 4 Server/Client

检测连接是否丢失的方法大致有两种：**keepalive**和**heart-beat**

1. tcp采用keepalive，它会先要求此连接一定时间没有活动（几个小时），然后发出数据段，经过多次尝试后，如果仍没有响应，则判断连接中断。**周期需要很长**的时间。
2. Heart-beat（心跳），它的原理和keepalive非常类似，都是发送一个信号给对方，如果多次发送都没有响应的话，则判断连接中断。它们的不同点在于heart-beat需要在tcp之上的应用层实现。heart-beat测试连接是否中断采用的时间间隔都比较短，可以自行决定当判断连接中断后应该采取的行为

端到端通信是针对传输层来说的，传输层为网络中的主机提供端到端的通信。在数据传输之前，在发送端与接收端之间（忽略中间有多少设备）为数据的传输建立一条链路

端到端的优点：链路建立之后，发送端知道接收端一定能收到，而且经过中间交换设备时不需要进行存储转发，因此传输延迟小。

端到端传输的缺点：（1）直到接收端收到数据为止，发送端的设备一直要参与传输。如果整个传输的延迟很长，那么对发送端的设备造成很大的浪费。（2）如果接收设备关机或故障，那么端到端传输不可能实现。

点到点通信是针对数据链路层或网络层来说的，因为数据链路层只负责直接相连的两个节点之间的通信，一个节点的数据链路层接受ip层数据并封装之后，就把数据帧从链路上发送到与其相邻的下一个节点。 

点到点的优点：（1）发送端设备送出数据后，它的任务已经完成，不需要参与整个传输过程，这样不会浪费发送端设备的资源。（2）即使接收端设备关机或故障，点到点传输也可以采用存储转发技术进行缓冲。

点到点的缺点：点到点传输的缺点是发送端发出数据后，不知道接收端能否收到或何时能收到数据。

HTTP：用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。HTTPS：是以安全为目标的HTTP通道，HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。

- https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。 
- http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。
- http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。 
- http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。

HTTP REFERER头：

1. HTTP Referer是header的一部分，告诉服务器该网页是从哪个页面链接过来的，服务器因此可以获得一些信息用于处理。
2. 防盗链。http请求发给服务器后，如果服务器要求必须是某个地址或者某几个地址才能访问，而你发送的referer不符合他的要求，就会拦截或者跳转到他要求的地址，然后再通过这个地址进行访问。
3. 防止恶意请求。比如静态请求是*.html结尾的，动态请求是*.shtml，那么由此可以这么用，所有的*.shtml请求，必须Referer为我自己的网站。
4. 空Referer定义：Referer头部的内容为空，或者，一个HTTP请求中根本不包含Referer头部（一个请求并不是由链接触发产生的）直接在浏览器的地址栏中输入一个资源的URL地址，那么这种请求是不会包含Referer字段的，因为这是一个“凭空产生”的HTTP请求，并不是从一个地方链接过去的。那么在防盗链设置中，允许空Referer和不允许空Referer有什么区别？允许Referer为空，意味着你允许比如浏览器直接访问。
5. 防御CSRF比对HTTP 请求的来源地址，如果Referer中的地址是安全可信任的地址，那么就放行

HTTP方法：

- GET： 用于请求访问已经被URI（统一资源标识符）识别的资源，可以通过URL传参给服务器
- POST：用于传输信息给服务器，主要功能与GET方法类似，但一般推荐使用POST方式。
- PUT： 传输文件，报文主体中包含文件内容，保存到对应URI位置。
- HEAD： 获得报文首部，与GET方法类似，只是不返回报文主体，一般用于验证URI是否有效。
- DELETE：删除文件，与PUT方法相反，删除对应URI位置的文件。
- OPTIONS：查询相应URI支持的HTTP方法。

1. GET请求在URL中传送的参数是有长度限制的，而POST没有。
2. GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。
3. GET参数通过URL传递，POST放在Request body中。
4. GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。
5. GET请求只能进行url编码，而POST支持多种编码方式。
6. GET请求会被浏览器主动cache，而POST不会，除非手动设置。
7. GET产生的URL地址可以被Bookmark，而POST不可以。
8. GET在浏览器回退时是无害的，而POST会再次提交请求。

http 1.0 :

1. 支持GET、POST和HEAD等请求方法
2. 默认不支持长连接，为了解决这个问题，有些浏览器在请求时，用了一个非标准的Connection字段。

http 1.1 :

1. 默认长连接(keep-alive)，http请求可以复用Tcp连接，客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。不过，规范的做法是，客户端在最后一个请求时，发送Connection: close，明确要求服务器关闭TCP连接。
2. 加入了管道机制，在同一个TCP连接里，允许多个请求同时发送，增加了并发性，进一步改善了HTTP协议的效率。
3. 新增了请求方式PUT、PATCH、OPTIONS、DELETE等
4. 支持文件断点续传
5. 客户端请求的头信息新增了Host字段，用来指定服务器的域名。
6. 一个TCP连接现在可以传送多个回应，势必就要有一种机制，区分数据包是属于哪一个回应的。这就是Content-length字段的作用，声明本次回应的数据长度。
7. 分块传输编码，使用Content-Length字段的前提条件是，服务器发送回应之前，必须知道回应的数据长度。

http/2.0 :

1. 多路复用，一个Tcp中多个http请求是并行的
2. 二进制格式编码传输
3. 头信息压缩： HTTP 协议不带有状态，每次请求都必须附上所有信息，请求的很多字段都是重复的。头信息使用gzip或compress压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表。
4. 服务端推送：允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送

http 3.0：

1. 减少了TCP三次握手及TLS握手时间，基于UDP协议的QUIC，因为UDP本身没有连接的概念，连接建立时只需要一次交互，半个握手的时间。
2. 多路复用丢包的线头阻塞，QUIC中一个TCP连接上的多个stream之间没有依赖。所以当发生丢包时，只会影响当前的stream
3. 优化重传策略，QUIC发送端在传送封包时，初始与重传的每一个封包都改用一个新的编号，每一个编号都唯一而且严格递增
4. 流量控制，一个stream就有可能用掉接收端所有的资源。QUIC采用了连线层和Stream层的流量控制，限制单一Stream可以占用的最大buffer size。
5. 连接迁移，QUIC的连接不受四元组的影响，当这四个元素发生变化时，原连接依然维持。QUIC连接不以四元组作为标识，而是使用一个64位的随机数，这个随机数被称为Connection lD

HTTP常见响应状态码：

- **200** : 从状态码发出的请求被服务器正常处理。
- **204** : 服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分【即没有内容】。
- **206** : 部分的内容（如：客户端进行了范围请求，但是服务器成功执行了这部分的干请求）。
- **301** : 跳转，代表永久性重定向（请求的资源已被分配了新的URI，以后已使用资源，现在设置了URI）。
- **302** : 临时性重定向（请求的资源已经分配了新的URI，希望用户本次能够使用新的URI来进行访问）。
- **303** : 由于请求对应的资源存在的另一个URI（因使用get方法，定向获取请求的资源）。
- **304** : 客户端发送附带条件的请求时，服务器端允许请求访问资源，但因发生请求未满足条件的情况后，直接返回了 304。
- **307** : 临时重定向【该状态码与302有着相同的含义】。
- **400** : 请求报文中存在语法错误（当错误方式时，需修改请求的内容后，再次发送请求）。
- **401** : 发送的请求需要有通过HTTP认证的认证信息。
- **403** : 对请求资源的访问被服务器拒绝了。
- **404** : 服务器上无法找到请求的资源。
- **500** : 服务器端在执行请求时发生了错误。
- **503** : 服务器暂时处于超负载或者是正在进行停机维护，现在无法处理请求。
- 1XX : 信息类状态码（表示接收请求状态处理）
- 2XX : 成功状态码（表示请求正常处理完毕）
- 3XX : 重定向（表示需要进行附加操作，已完成请求）
- 4XX : 客户端错误（表示服务器无法处理请求）
- 5XX : 服务器错误状态码（表示服务器处理请求的时候出错）

1. Cookie与Session都是会话的一种方式。
2. cookie数据存放在客户的浏览器上，session数据放在服务器上。
3. cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗 考虑到安全应当使用session。
4. session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能 考虑到减轻服务器性能方面，应当使用COOKIE。
5. 单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。

访问百度网站的流程：

- 域名解析
- 得到www.baidu.com对应的IP地址之后，我的主机会向该主机发送TCP三次握手，进行连接。
- 使用HTTP协议发送请求数据给web服务器。
- Web服务器收到数据请求之后，通过查询自己的服务器得到相应的结果，将结果返回给我的计算机。
- 我的计算机收到返回的数据后，浏览器将其显示出来。
- 我的计算机进行四次挥手，关闭TCP连接。