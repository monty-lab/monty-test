---
layout: post
title: C++基础
date: 2023-10-28 17:51 +0800
categories: [笔记]
tags: [C++]
toc:  true
---

## 1 C++语言基础

### 1.1 C++语言特点

-  C++在C语言基础上引入了面对对象的机制，同时也兼容C语言。 
-  C++有三大特性封装、继承、多态。 
-  C++语言编写出的程序结构清晰、易于扩充，程序可读性好。 
-  C++生成的代码质量高，运行效率高，仅比汇编语言慢10%～20%； 
-  C++更加安全，增加了const常量、引用、四类cast转换（static_cast、dynamic_cast、const_cast、reinterpret_cast）、智能指针、try—catch等等； 

（编译型）C跟C++是全部翻译，再执行的语言；（解释型）Java与python、php是边执行边翻译的语言。所以C和C++运行效率高

编译型：预编译，编译，汇编，链接到最后的可执行文件；

解释型语言：词法分析，语法分析，转化为抽象语法树AST，生成opcodes（由解释器完成指令集的转化，解释器是个程序，语言作为参数传入），然后解释为机器指令。所以C++的可执行文件不能跨平台，解释型语言的解释器不能跨平台。

### 1.2 C和C++比较

- C++是面对对象的编程语言；C语言是面对过程的编程语言。
- C++增加了不少新特性来改善安全性，如const常量、引用、cast转换、智能指针、try—catch等等
- C++可复用性高，C++引入了模板的概念
- C语言是C++的子集，C++可以很好兼容C语言

> C语言没有布尔变量

### 1.3 面向对象和面向过程区别

面向对象：结构清晰，程序是模块化和结构化；易扩展和维护；但是牺牲了性能

面向过程：流程化使得编程任务明确，在开发之前基本考虑了实现方式和最终结果，效率高，面向过程强调代码的短小精悍，善于结合数据结构来开发高效率的程序。

### 1.4 C++关键字

#### 1.4.1 include

尖括号<>的头文件是系统文件，查找路径：编译器设置的头文件路径-->系统变量。

双引号""的头文件是自定义文件，查找路径：当前头文件目录-->编译器设置的头文件路径-->系统变量。

#### 1.4.2 struct

在C++中，struct数据结构集合，class是对象数据封装；

struct 中默认的访问控制权限是 public 的，而 class 中默认的访问控制权限是 private 的

在继承关系中，struct 默认是公有继承，而 class 是私有继承

class 关键字可以用于定义模板参数，就像 typename，而 struct 不能用于定义模板参数

```cpp
template<typename T, typename Y>    // 可以把typename 换成 class 
int Func(const T& t, const Y& y) {}
```

|     | C | C++ |
| --- | --- | --- |
| 成员函数 | 不能有 | 可以（虚函数也可以） |
| 静态成员 | 不能有 | 可以 |
| 访问控制 | 默认public，不能修改 | public/private/protected |
| 继承关系 | 不可以继承 | 可从类或者其他结构体继承 |
| 初始化 | 不能直接初始化数据成员 | 可以 |

C中使用结构体需要加上 struct 关键字，或者对结构体使用 typedef 取别名，而 C++ 中可以省略 struct 关键字直接使用

```c
// 因为没有结构体名，后面就没法用该结构体定义新的变量。
// stu 结构体名，stu1 stu2 结构体变量。
struct stu {
    char *name;  //姓名
} stu1, stu2
```

如何判断结构体是否相等？能否用 memcmp 函数判断结构体相等？

需要重载操作符 == 判断两个结构体是否相等，不能用函数 memcmp 来判断两个结构体是否相等，因为 memcmp 函数是逐个字节进行比较的，而结构体存在内存空间中保存时存在字节对齐，字节对齐时补的字节内容是随机的，会产生垃圾值，所以无法比较。

#### 1.4.3 extern

添加extern声明，可以让编译器把“寻找定义”这件事情推迟到链接阶段，而不会在编译阶段报“没有定义”的错误。

**定义和声明的区别：** 声明用来告诉编译器变量的名称和类型，而不分配内存，不赋初值。定义为了给变量分配内存，可以为变量赋初值。

```cpp
// a.cpp想调用b.cpp中的全局delayms函数
// 方法一：会引入大量头文件，进而会引入大量的无关函数。
#include <b.h>
// 方法二：不会引入大量头文件，进而不会引入大量的无关函数。
// 会加速程序的编译（确切的说是预处理）的过程，节省时间。
extern void delayms();
```

**注意：** 函数的声明语句中，关键字extern可以省略。函数形参名可以省略，只关注变量类型

如果在头文件中定义全局变量，当该头文件被多个文件 include 时，该头文件中的全局变量就会被定义多次，导致重复定义，因此不能再头文件中定义全局变量。

在C中，导入C函数的关键字是**extern**，表达形式为extern “C”， extern "C"的主要作用就是为了能够正确实现C代码调用其他C语言代码。加上extern "C"后，会指示编译器这部分代码按C语言的进行编译，而不是C++的。

```cpp
//在C++程序里边声明该函数，会指示编译器这部分代码按C语言的进行编译
extern "C" int strcmp(const char *s1, const char *s2);

//在C++程序里边声明该函数
extern "C"{
    #include <string.h>//string.h里边包含了要调用的C函数的声明
}
```

使用导入原因：假设某个函数原型是

```cpp
void foo(int x, int y);
```

该函数被C编译器编译后在库中的名字为_foo，而C++编译之后会的名字是_foo_int_int。为了解决名字匹配问题可以使用导入操作。

#### 1.4.4 static

**定义全局静态变量和局部静态变量**：初始化的静态变量会在数据段分配内存，未初始化的静态变量会在BSS段分配内存。直到程序结束，静态变量始终会维持前值。对于C语言的全局和静态变量，初始化发生在任何代码执行之前，属于编译期初始化。而C++标准规定：全局或静态对象当且仅当对象首次用到时才进行构造。

静态函数和静态变量只能在**本源文件**中使用；

**static关键字可以用于定义类中的静态成员函数和静态成员变量**：所有对象的静态数据成员都**共享**这一块静态存储空间。

当调用一个对象的非静态成员函数时，系统会把该对象的起始地址赋给成员函数的this指针。而静态成员函数不属于任何一个对象，因此C++规定**静态成员函数没有this指针**。既然它没有指向某一对象，也就无法对一个对象中的非静态成员进行访问。

为什么不能在头文件定义static变量：使用static定义变量证明该变量的作用域范围仅在该源文件内，其他源文件不能访问。如果在头文件中定义static变量，证明包含了所有这个头文件的源文件都定义了该变量，会造成变量多次定义浪费内存，而且不是真正的全局变量。

**static 全局变量和普通全局变量的异同：**

- 普通全局变量和 static 全局变量都是静态存储方式
- 普通全局变量的作用域是整个源程序，当一个源程序由多个源文件组成时，普通全局变量在各个源文件中都是有效的；静态全局变量则限制了其作用域，即只在定义该变量的源文件内有效，在同一源程序的其它源文件中不能使用它。
- 静态全局变量只初始化一次，防止在其他文件中使用

**全局变量** ：在 C++ 中，全局变量的初始化顺序是由其定义的顺序决定的，但这只对同一个编译单元（也就是同一个源文件及其包含的头文件）中的全局变量有效。

当涉及到不同的编译单元时，全局变量的初始化顺序就无法确定

C++ 提供了一种技术，通常被称为 "构造函数的惰性初始化" 或者 "Schwarz Counter" 技巧。方式是将全局变量封装在函数内部

```cpp
// instance 的初始化会延迟到 getInstance() 函数首次被调用时才进行
MyClass& getInstance() {
    static MyClass instance;
    return instance;
}
```

#### 1.4.5 define

define用于定义宏，宏也可以用于定义常量。

const和define**都用于常量**定义时，它们的区别有：

-  const生效于编译的阶段；define生效于预处理阶段。 
-  const 定义的常量占用静态存储区的空间，程序运行过程中只有一份；define 定义的宏常量，在程序中使用多少次就会进行多少次替换，内存中有多个备份，占用的是代码段的空间。 
-  const定义的常量是带类型的；define定义的常量不带类型。因此define定义的常量不利于类型检查。 

#### 1.4.6 const

const用于定义常量

```cpp
const int a;     //指的是a是一个常量，不允许修改。
const int *a;    //a指针所指向的内存里的值不变，即（*a）不变
int const *a;    //同const int *a;
int *const a;    //a指针所指向的内存地址不变，即a不变
const int *const a;   //都不变，即（*a）不变，a也不变
```

#### 1.4.7 ++

**赋值顺序不同**：++ i 是先加后引用；i ++ 是先引用后加；++i和i++都是分两步完成的。

**效率不同**：后置++执行速度比前置的慢。++i 是i=i+1，表达式的值就是i本身；i++也是i=i+1，但表达式的值是加1前的副本，由于要先保存副本，因此效率低一些。

**i++ 不能作为左值，而++i 可以**：左值是对应内存中有确定存储地址的对象的表达式的值

```cpp
int i = 0;
int *p1 = &(++i);//正确
int *p2 = &(i++);//错误
++i = 1; //正确
i++ = 1; //错误
```

**两者都不是原子操作**

#### 1.4.8 new、malloc

new是操作符，而malloc是函数。

new在调用的时候先分配内存，在调用构造函数，释放的时候调用析构函数；而malloc没有构造函数和析构函数。

malloc需要给定申请内存的大小，返回的指针需要强转；new会调用构造函数，不用指定内存的大小，返回指针不用强转。

new可以被重载；malloc不行

new分配内存更直接和安全。

new发生错误抛出异常，malloc返回null

**malloc底层实现：**

1. malloc() 首先查看自由列表（free list），这是一个记录了已经释放但还未被重新使用的内存块的列表。如果有足够大的内存块可以满足请求，那么这个内存块就会被返回。
2. 如果自由列表中没有足够大的内存块，malloc() 就会通过 brk() 或 mmap() （取决于请求的内存大小和特定的系统实现）系统调用来增加程序的堆大小。然后，它会将这些新获取的内存添加到自由列表中。
3. 一旦堆大小增加，malloc() 就会再次查看自由列表，此时应该能找到一个足够大的内存块来满足请求了。然后，这个内存块就会从自由列表中移除，并返回给请求者。

malloc采用的是内存池的管理方式，以减少内存碎片。先申请大块内存作为堆区，然后将堆区分为多个内存块。当用户申请内存时，直接从堆区分配一块合适的空闲快。采用隐式链表将所有空闲块，每一个空闲块记录了一个未分配的、连续的内存地址。

**new底层实现：** 关键字new在调用构造函数的时候实际上进行了如下的几个步骤：

1. 分配内存创建一个新的对象(初始化)
2. 将构造函数的作用域赋值给这个新的对象（因此this指向了这个新的对象）
3. 执行构造函数中的代码（为这个新对象添加属性）
4. 返回新对象

在第一步中 new 实际上调用了两个函数，operator new 和 构造函数
![new_process.png](/assets/img/new_process.png)

```cpp
/*
operator new：该函数实际通过malloc来申请空间，当malloc申请空间成功时直接返回；申请空间失败，
尝试执行空 间不足应对措施，如果改应对措施用户设置了，则继续申请，否则抛异常。
*/
void *__CRTDECL operator new(size_t size) _THROW1(_STD bad_alloc) 
{
    // try to allocate size bytes
    void *p;
    while ((p = malloc(size)) == 0)
    if (_callnewh(size) == 0)
    {
        // report no memory
        // 如果申请内存失败了，这里会抛出 bad_alloc 类型异常
        static const std::bad_alloc nomem;
        _RAISE(nomem);
    }
    return (p);
}
```

#### 1.4.9 strcpy和memcpy

1. strcpy和memcpy都是在C语言和C++语言中用于复制内存块的函数，但它们在使用和效率上有所不同。
2. strcpy用于将一个以null结尾的字符串从源地址复制到目标地址。它会复制整个字符串，包括null终止符，直到遇到null为止。如果源字符串长度超过目标地址所分配的内存空间，则会导致内存越界和缓冲区溢出问题。
3. memcpy用于将一段内存块从源地址复制到目标地址，可以复制任意长度的内存块，而不仅限于字符串。memcpy不会关心内存块中是否有null终止符，而只是按照给定的长度复制内存块。因此，使用memcpy时需要确保目标地址有足够的内存空间，否则也会导致缓冲区溢出问题。

在效率方面，memcpy通常比strcpy更快，因为它不需要扫描整个字符串来查找null终止符。另外，memcpy也可以进行一些优化，例如使用字长操作来提高复制速度。但是，由于strcpy具有更简单的语法和更高的可读性，因此在处理字符串时，通常首选strcpy函数。

```cpp
char* strcpy(char* dest,const char* src);
char* strncpy(char* dest,const char* src,size_t n);
// memcpy没有考虑内存重叠的情况，所以如果两者内存重叠，会出现错误。
void* memcpy(void* dest,const void* src,size_t n);
```

#### 1.4.10 sizeof 和 strlen 

1. strlen 是头文件中的函数，在程序运行中计算长度，sizeof 是 C++ 中的运算符，在编译时计算长度。
2. strlen 测量的是字符串的实际长度（其源代码如下），以 \0 结束。而 sizeof 测量的是字符数组的分配大小。
3. 若字符数组 arr 作为函数的形参，sizeof(arr) 中 arr 被当作字符指针来处理，strlen(arr) 中 arr 依然是字符数组
4. sizeof 的参数可以是类型，也可以是变量；strlen 的参数必须是 char* 类型的变量

#### 1.4.11 inline

**类内定义成员函数默认是内联函数**

类外定义成员函数，若想定义为内联函数，需用关键字声明；可以在类内声明时不加 inline 关键字，而在类外定义函数时加上 inline 关键字。可以在声明函数和定义函数的同时加上 inline；也可以只在函数声明时加 inline，而定义函数时不加 inline。

内联函数的作用：

1. 消除函数调用的开销。
2. 去除函数只能定义一次的限制，内联函数可以在头文件中被定义，并被多个 .cpp 文件 include，而不会有重定义错误。

内联函数一定会被编译器在调用点展开吗？

- inline 只是对编译器的建议，而非命令。编译器可以选择忽视 inline。当程序员定义的 inline 函数包含复杂递归，或者 inlinie 函数本身比较长，编译器一般不会将其展开，而仍然会选择函数调用。

“调用”普通函数时，一定是调用吗？

- 即使是普通函数，编译器也可以选择进行优化，将普通函数在“调用”点展开。

既然内联函数在编译阶段已经在调用点被展开，那么程序运行时，对应的内存中不包含内联函数的定义，对吗？

- 首先，编译器可以选择调用内联函数，而非展开内联函数。因此，内存中仍然需要一份内联函数的定义，以供调用。而且，一致性是所有语言都应该遵守的准则。普通函数可以有指向它的函数指针，那么，内敛函数也可以有指向它的函数指针，因此，内存中需要一份内联函数的定义，使得这样的函数指针可以存在。

内联函数和宏函数

1. 内联函数是在编译时展开，而宏在编译预处理时展开；在编译的时候，内联函数直接被嵌入到目标代码中去，而宏只是一个简单的文本替换。
2. 内联函数是真正的函数，和普通函数调用的方法一样，在调用点处直接展开，避免了函数的参数压栈操作，减少了调用的开销。而宏定义编写较为复杂，常需要增加一些括号来避免歧义。
3. 宏定义只进行文本替换，不会对参数的类型、语句能否正常编译等进行检查。而内联函数是真正的函数，会对参数的类型、函数体内的语句编写是否正确等进行检查。

**内联函数使用的条件：**

内联是以代码膨胀（复制）为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。以下情况不宜使用内联：

（1）如果函数体内的代码比较长，使用内联将导致内存消耗代价较高。

（2）如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大。

#### 1.4.12 volatile

volatile 的作用：当对象的值可能在程序的控制或检测之外被改变时，应该将该对象声明为 violatile，告知编译器不应对这样的对象进行优化。

volatile不具有原子性。

volatile 对编译器的影响：使用该关键字后，编译器不会对相应的对象进行优化，即不会将变量从内存缓存到寄存器中，防止多个线程有可能使用内存中的变量，有可能使用寄存器中的变量，从而导致程序错误。

#### 1.4.13 final

C++11的关键字final有两个用途。第一，它阻止了从类继承；第二，阻止一个虚函数的重载。

#### 1.4.14 memcmp()

```cpp
int memcmp(const void *str1, const void *str2, size_t n)
// 如果返回值 < 0，则表示 str1 小于 str2。
// 如果返回值 > 0，则表示 str1 大于 str2。
// 如果返回值 = 0，则表示 str1 等于 str2。
```

#### 1.4.15 typedef

typedef 是关键字，在编译时处理，有类型检查功能，用来给一个已经存在的类型一个别名，但不能在一个函数定义里面使用 typedef
\#define 作为预处理指令，在编译预处理时进行替换操作，不作正确性检查，只有在编译已被展开的源程序时才会发现可能的错误并报错

功能：typedef 用来定义类型的别名，方便使用。#define 不仅可以为类型取别名，还可以定义常量、变量、编译开关等。

作用域：#define 没有作用域的限制，只要是之前预定义过的宏，在以后的程序中都可以使用，而 typedef 有自己的作用域(全局或者局部)。

```cpp
#define INTPTR1 int*
typedef int* INTPTR2;
```

### 1.5 数组

存储一个固定大小的相同类型元素的顺序集合；数组的存储空间，不是在静态区就是在栈上。

数组长度大小：sizeof（数组名）/sizeof（数据类型）

只有在定义数组时才可以使用初始化，不能将一个数组赋值给另一个数组。

```cpp
// 数组的长度是常量
int age[10];
int (&p)[10] = age;
int *p = num;
int cards[100] = {1};				// 正确初始化 3: 第一个元素为1，后续99个元素为int默认类型0
short age[] = {1,2,3,4,5};			// 正确初始化 4: 需要编译器来计算元素个数
double score[3]{1.0, 2.0, 90.0};	// 正确初始化 5: c++11新增
```

做全局变量时，元素全部初始化为类型默认值（不指定初始化值时），如 `int-0`。做局部变量时，不使用花括号`{}`时（不指定初始化值），元素为类型随机值。使用花括号`{}`时，数据按顺序初始化至数组内，剩余元素全部初始化为类型默认值，如 `int-0`。

char数组：

以空字符`null-char`为结尾，空字符写作`\0`，其`ASCII`码值为0，用来标记字符串的结尾。

```cpp
char name[4] = {'y','u','a','n'};		// 字符数组，这不是字符串
char name[5] = {'y','u','a','n','\0'};	// 字符串
char name[10] = "yuan.";    // {'y', 'u', 'a', 'n', '.', '\0', '\0', '\0', '\0', '\0'};
// char*或者char[] 转string直接赋值即可
char *a = "hello";
char b[] = "hello";
string s = a;
// string提供的c_str()或者data()函数。其中c_str()函数返回一个以'\0'结尾的字符数组，
// 而data()仅返回字符串内容，而不含有结束符'\0'。
```

**指针、数组名**

数组名、指针、数组第一个元素均表示数组第一个元素的地址。一般可以使用相同的方式使用 **数组名** 和 **指针名**，二者区别在于：可以修改指针指向的地址，数组名是常量；`sizeof(指针名)`为指针长度，`sizeof(数组名)`为数组长度。

```cpp
int a[3][4];  
int (*p)[4];  //该语句是定义一个数组指针，指向含4个元素的一维数组
p = a;        //将该二维数组的首地址赋给p，也就是a[0]或&a[0][0]
p++;          //该语句执行过后，也就是p=p+1；p跨过行a[0][]指向了行a[1][]
              //所以数组指针也称指向一维数组的指针，亦称行指针。

//*(p[i]+j)、*(*(p+i)+j)、(*(p+i))[j]、p[i][j]。其中，优先级：()>[]>*。
char *str = "hello,douya!";
str[2] = 'a'; // 不能成功，C++不允许常量数据修改
```
### 1.6 指针（函数指针、nullptr、野指针）

**函数指针**是指向函数的指针变量，每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。

```cpp
int func(int a);  
int (*f)(int a);  
f = &func;
```

函数指针的应用场景：**回调**

指针函数本质是一个函数，其返回值为指针。

```cpp
指针函数：int *fun(int x,int y);
函数指针：int (*fun)(int x,int y);
```

**nullptr**：

```cpp
class animal{
public:
    void sleep(){ cout << "animal sleep" << endl; }
    void breathe(){ cout << "animal breathe haha" << endl; }
};

class fish :public animal{
public:
    void breathe(){ cout << "fish bubble" << endl; }
};

animal *pAn=nullptr;
pAn->breathe();   // 输出：animal breathe haha
fish *pFish = nullptr;
pFish->breathe(); // 输出：fish bubble
```

在**编译时对象**就绑定了**函数地址**，和指针空不空没关系。pAn->breathe()；编译的时候，函数的地址就和指针pAn绑定了；调用breath(*this)，this就等于pAn。由于函数中没有需要解引用this的地方，所以函数运行不会出错，但是若用到this，因为this=nullptr，运行出错

**野指针**就是指针指向的位置是不可知的，原因释放内存后指针不及时置空（野指针），依然指向了该内存，那么可能出现非法访问的错误。避免办法：初始化置NULL、申请内存后判空、指针释放后置NULL、使用智能指针

指针和引用区别：

- 指针所指向的内存空间在程序运行过程中可以改变，而引用所绑定的对象一旦绑定就不能改变。（是否可变）
- 指针本身在内存中占有内存空间，引用相当于变量的别名，在内存中不占内存空间。（是否占内存）
- 指针可以为空，但是引用必须绑定对象。（是否可为空）
- 指针可以有多级，但是引用只能一级。（是否能为多级）

### 1.7 函数

函数调用：调用函数时会将下一条指令的地址压栈，调用函数返回知道下一行代码的位置。

传值方式:

-  值传递：形参即使在函数体内值发生变化，也不会影响实参的值； 
-  引用传递：形参在函数体内值发生变化，会影响实参的值； 
-  指针传递：在指针指向没有发生改变的前提下，形参在函数体内值发生变化，会影响实参的值； 

值传递用于对象时，整个对象会拷贝一个副本，这样效率低；而引用传递用于对象时，不发生拷贝行为，只是绑定对象，更高效；指针传递同理，但不如引用传递安全。

在大多数编程语言中，引用不会占用内存空间，因为引用只是指向现有的内存空间的别名。在C++中，引用是指向变量的别名，与指针不同的是，引用不能为null或指向其他变量。在Java中，引用是对象的句柄，可以在程序中传递和使用，但实际上它只是一个32位或64位的指针，指向分配在堆上的对象实例。在Python中，所有变量都是引用，因此不需要显式地使用引用操作符。

当程序使用引用时，它们只是将变量名与内存地址关联起来，因此不会产生额外的内存分配。但是，如果在函数中返回一个引用，则返回值实际上是指向函数内部变量的引用。这样做可能会导致问题，因为当函数返回时，其内部变量将被销毁，而返回的引用可能会指向已经不存在的内存位置，这被称为悬垂引用（dangling reference）问题。因此，必须非常小心地使用返回引用的函数。

### 1.8 模板

模板实现原理：编译器从函数模板通过具体类型产生不同的函数；编译器会对函数模板进行两次编译：在声明的地方对模板代码本身进行编译（检查语法的正确性），在调用的地方对参数替换后的代码进行编译。

**虚函数不能为模板函数**，每个含有虚函数的类中都有一个虚函数表，该虚函数表存储着该类的所有的虚函数的地址，因此，虚函数为模板函数时，该表的大小是不知道的

函数模板和类模板的区别？

- 实例化方式不同：函数模板实例化由编译程序在处理函数调用时自动完成，类模板实例化需要在程序中显式指定。
- 实例化的结果不同：函数模板实例化后是一个函数，类模板实例化后是一个类。
- 默认参数：类模板在模板参数列表中可以有默认参数。
- 特化：函数模板只能全特化；而类模板可以全特化，也可以偏特化。
- 调用方式不同：函数模板可以隐式调用，也可以显式调用；类模板只能显式调用。

可变参数模板：接受可变数目参数的模板函数或模板类。将可变数目的参数被称为参数包，包括模板参数包和函数参数包。用省略号来指出一个模板参数或函数参数表示一个包，在模板参数列表中，class… 或 typename… 指出接下来的参数表示零个或多个类型的列表；一个类型名后面跟一个省略号表示零个或多个给定类型的非类型参数的列表。当需要知道包中有多少元素时，可以使用 sizeof… 运算符。

```cpp
template <typename T, typename... Args> // Args 是模板参数包
void foo(const T &t, const Args&... args); // 可变参数模板，rest 是函数参数包

template <typename T, typename... Args>
void print_fun(const T &t, const Args &...args) {
    cout << t << " ";
    print_fun(args...);
}

int main() {
    print_fun("Hello", "wolrd", "!");
    return 0;
}
```

模板特化：

模板特化的原因：模板并非对任何模板实参都合适、都能实例化，某些情况下，通用模板的定义对特定类型不合适，可能会编译失败，或者得不到正确的结果。因此，当不希望使用模板版本时，可以定义类或者函数模板的一个特例化版本。

模板特化：模板参数在某种特定类型下的具体实现。分为函数模板特化和类模板特化

- 函数模板特化：将函数模板中的全部类型进行特例化，称为函数模板特化。
- 类模板特化：将类模板中的部分或全部类型进行特例化，称为类模板特化。

特化分为全特化和偏特化：

- 全特化：模板中的模板参数全部特例化。
- 偏特化：模板中的模板参数只确定了一部分，剩余部分需要在编译器编译时确定。

说明：要区分下函数重载与函数模板特化，定义函数模板的特化版本，本质上是接管了编译器的工作，为原函数模板定义了一个特殊实例，而不是函数重载，函数模板特化并不影响函数匹配。

### 1.9 泛型编程

泛型编程实现的基础：模板。模板是创建类或者函数的蓝图或者说公式，当时用一个 vector 这样的泛型，或者 find 这样的泛型函数时，编译时会转化为特定的类或者函数。

泛型编程：容器、迭代器、算法等都是泛型编程的实现实例。

## 2 C++内存管理

### 2.1 C++内存管理
![image.png](/assets/img/cpp_store_manage.png)

如上图，**从低地址到高地址，一个程序由代码段、数据段、** **BSS** **段组成。**

1. **代码段：** 存放程序执行代码的一块内存区域。只读，代码段的头部还会包含一些只读的常数变量。 
2.  **数据段：** 存放程序中已初始化的全局变量和静态变量的一块内存区域。 
3.  **BSS** 段：存放程序中未初始化或者**初始化为0的全局变量和静态变量**的一块内存区域。 特点是可读写的，在程序执行之前BSS段会自动初始化为0。
4.  可执行程序在运行时又会多出两个区域：堆区和栈区。
**堆区：** 动态申请内存用。堆从低地址向高地址增长。
**栈区：** 存储局部变量、函数参数值。栈从高地址向低地址增长。是一块连续的空间。 
5.  最后还有一个**文件映射区**，位于堆和栈之间。 

**内核空间：** 主要用于存储内核代码和数据，以及进程控制块(PCB)、驱动程序、缓冲区、文件系统等。

函数调用的过程，是一个上下文切换的过程，首先要保存现场、然后将函数的返回地址、函数的参数及局部变量压栈、执行函数、返回恢复现场。

**常见的内存错误及其对策**：

（1）内存分配未成功，却使用了它。

（2）内存分配虽然成功，但是尚未初始化就引用它。

（3）内存分配成功并且已经初始化，但操作越过了内存的边界。

（4）忘记了释放内存，造成内存泄露。

（5）释放了内存却继续使用它。

对策：

（1）定义指针时，先初始化为NULL。

（2）用malloc或new申请内存之后，应该立即检查指针值是否为NULL。防止使用指针值为NULL的内存。

（3）不要忘记为数组和动态内存赋初值。防止将未被初始化的内存作为右值使用。

（4）避免数字或指针的下标越界，特别要当心发生“多1”或者“少1”操作

（5）动态内存的申请与释放必须配对，防止内存泄漏

（6）用free或delete释放了内存之后，立即将指针设置为NULL，防止“野指针”

（7）使用智能指针。

delete如何知道释放内存的大小

需要在 new [] 一个对象数组时，需要保存数组的维度，C++ 的做法是在分配数组空间时多分配了 4 个字节的大小，专门保存数组的大小，在 delete [] 时就可以取出这个保存的数，就知道了需要调用析构函数多少次了。

### 2.2 堆、栈、常量区

**堆栈区别**：

-  堆栈空间分配不同。栈由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等；堆一般由程序员分配释放。 
-  栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。堆内存池的方式。
-  在函数调用时，第一个进栈的是主函数中函数调用后的下一条指令的地址，然后是函数的各个参数，然后是函数中的局部变量。一般是在堆的头部用一个字节存放堆的大小，堆内容由程序员安排。
- 栈在内存中是连续的一块空间（向低地址扩展）最大容量是系统预定好的，堆在内存中的空间（向高地址扩展）是不连续的。
-  **堆栈数据结构不同**。堆类似数组结构；栈类似栈结构，先进后出。 

### 2.3 内存泄漏

简单地说就是申请了一块内存空间，使用完毕后没有释放掉。

- 堆内存泄漏，new/mallc分配内存，未使用对应的delete/free回收
- 系统资源泄漏， Bitmap，handle，socket等资源未释放
- 没有将基类析构函数定义称为虚函数，（使用基类指针或者引用指向派生类对象时）派生类对象释放时将不能正确释放派生对象部分。

**解决办法：**

1. 检查malloc/new和free/delete是否匹配
2. 智能指针，它们可以自动管理内存的生命周期
3. RAII是一种编程范式，它将资源的生命周期与对象的生命周期挂钩。只要确保在构造函数中获取资源，在析构函数中释放资源，就能避免大部分的内存泄漏问题。
4. 使用内存分析工具：有许多工具可以帮助检测和定位内存泄漏，例如AddressSanitizer等。这些工具通常会告诉你哪些内存块被分配但未被释放，以及这些内存块是在哪里被分配的。

```shell
g++ -fsanitize=address -g your_code.cpp -o your_program
```

### 2.4 内存对齐

类的大小取决于其成员变量和虚拟函数等内容。一般而言：

- 对于非静态成员变量，它们都计入类的大小。
- 静态成员变量不计入类的大小，因为静态成员不属于类对象，而是全局存在的。
- 如果类有虚函数，那么还需考虑虚函数表指针的大小（通常是一个指针的大小）。

在多继承情况下，有多少个基类就有多少个虚函数表指针，前提是基类要有虚函数才算上这个基类。

空类型对象不包含任何信息，大小却不是0。这是因为当声明该类型的对象的时候，它必须在内存中占有一定的空间，否则无法使用这些对象。至于占用多少内存，由编译器决定。**C++中每个空类型的实例占1Byte空间。**

```cpp
class A {
private:
    static int s_var; // 不影响类的大小
    const int c_var;  // 4 字节
    int var;          // 8 字节 4 + 4 (int) = 8
    char var1;        // 12 字节 8 + 1 (char) + 3 (填充) = 12
public:
    A(int temp) : c_var(temp) {} // 不影响类的大小
    ~A() {}                      // 不影响类的大小
    virtual void f() { cout << "A::f" << endl; }

    virtual void g() { cout << "A::g" << endl; }

    virtual void h() { cout << "A::h" << endl; } // 24 字节 12 + 4 (填充) + 8 (指向虚函数的指针) = 24
};
```

struct内存对齐原则：

- 结构体变量的首地址能够被其最宽基本类型成员大小与对齐基数（**VS编译器的基数为8**）中的较小者所整除；
- 结构体每个成员相对于结构体首地址的偏移量 （offset） 都是该成员大小与对齐基数中的较小者的整数倍，如有需要编译器会在成员之间加上填充字节 （internal padding）；
- 结构体的总大小为结构体最宽基本类型成员大小与对齐基数中的较小者的整数倍，如有需要编译器会在最末一个成员之后加上填充字节 （trailing padding）。

union内存对齐原则：

sizeof(union)，以结构里面size最大元素为union的size（同时满足最宽基本类型成员的整数倍），因为在某一时刻，union只有一个成员真正存储于该地址。

```cpp
union example {  
    int a[5];  
    char b;  
    double c;  
};  
int result = sizeof(example);  
/*
如果以最长20字节为准，内部double占8字节，这段内存的地址0x00000020并不是double的整数倍，
只有当最小为0x00000024时可以满足整除double（8Byte）同时又可以容纳int a[5]的大小，
所以正确的结果应该是result=24
*/

struct example {  
    int a[5];  
    char b;  
    double c;  
}test_struct;
int result = sizeof(test_struct);  
/*
如果我们不考虑字节对齐，那么内存地址0x0021不是double（8Byte）的整数倍，所以需要字节对齐，
那么此时满足是double（8Byte）的整数倍的最小整数是0x0024，说明此时char b对齐int扩充了三个字节
所以最后的结果是result=32
*/

struct example {  
    char b;  
    double c;  
    int a;  
}test_struct;  
int result = sizeof(test_struct);  
/*
字节对齐除了内存起始地址要是数据类型的整数倍以外，还要满足一个条件，那就是占用的内存空间大小需
要是结构体中占用最大内存空间的类型的整数倍，所以20不是double（8Byte）的整数倍，我们还要扩充四
个字节，最后的结果是result=24
*/
```

**什么是字节对齐？**

现代计算机中内存空间的基础单元是字节(byte)，从理论层面上讲，对于任何数据类型的变量的访问，都可以从**任何地址开始**。但是物理层面实现时，访问特定类型变量的时候经常需要在特定的内存地址访问，一般时以2，4或8的倍数的字节块来读写内存。

**为什么要字节对齐？**

需要字节对齐的根本原因在于CPU访问数据的效率问题。一些平台对某些特定类型的数据只能从某些特定地址开始存取。比如有些平台每次读都是从偶地址开始，如果一个int型（假设为32位系统）如果存放在偶地址开始的地方，那么一个读周期就可以读出这32bit，而如果存放在奇地址开始的地方，就需要2个读周期，并对两次读出的结果的高低字节进行拼凑才能得到该32bit数据。显然在读取效率上下降很多。 

### 2.5 atomic

C++11起提供了atomic，可以使用它定义一个原子类型。成员函数：atomic提供了一些与原子操作有关的成员函数。

| **成员函数** | **说明** |
| --- | --- |
| store | 原子地以非原子对象替换原子对象的值 |
| load | 原子地获得原子对象的值 |

```cpp
// 定一个int64_t的原子类型
std::atomic<int64_t> value;
int64_t x = 10;
value.store(x, std::memory_order_relaxed);
```

需要注意的是atomic变量不支持拷贝，因此我们不能让一个atomic变量等于另一个atomic变量。

六种内存操作选项代表三种内存模型，分别是：排序一致序列(memory_order_seq_cst)，获取-释放序列(memory_order_consume, memory_order_acquire, memory_order_release和memory_order_acq_rel)和松散序列(memory_order_relaxed)。

- 排序一致性序列是对原子变量最强的约束，它会使一个多线程程序以某种特殊的排序执行，就像单线程一样。
- 松散序列只保证此次操作是原子的。
- memory_order_acquire在读取时可以加此参数，其之后的操作不能重排到该指令之前
- memory_order_release在写入时可以加此参数，之前的操作不能排在该操作之后
- memory_order_consume表示在代码中这条语句后面所有与这块内存有关的读写操作都无法被重排到这个操作之前
- memory_order_acq_rel相当于memory_order_release和memory_order_acquire的结合，同时约束该语句前面语句和后面语句的顺序。

## 3 面对对象

### 3.1 面对对象特征

面向对象是将数据与函数绑定到一起，三大特征是封装、继承、多态。

封装：将数据和操作数据的方法进行有机结合，隐藏对象的属性和实现细节，仅对外公开接口来和对象进行 交互。

继承：可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。

多态：用父类型别的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。实现多态，有二种方式，重写，重载。

### 3.2 构造函数和析构函数

#### 3.2.1 无参构造函数和有参构造函数

当创建一个对象时，构造函数会被编译器自动调用，用来初始化对象的数据成员。当编译器在类声明中找不到任何构造函数时，会生成一个公有的默认构造函数。数据成员的**初始化顺序取决于它们在类中被声明的顺序**,而与它们在成员初始化列表中出现的顺序无关。**有了有参构造函数，编译器就不提供默认的构造函数。**

对**const类型的数据**成员进行初始化时不能直接赋值，对const类型的数据成员进行初始化时必须为构造函数添加一个初始化列表。

定义一个空类，默认会生成哪些函数？

无参的构造函数、拷贝构造函数、赋值运算符、析构函数（非虚）、两个取址运算符

```cpp
class A {
public:
    A(){};                                       // 缺省构造函数
    A(const A &tmp){};                           // 拷贝构造函数
    ~A(){};                                      // 析构函数
    A &operator=(const A &tmp){};                // 赋值运算符
    A *operator&() { return this; };             // 取址运算符
    const A *operator&() const { return this; }; // 取址运算符（const 版本）
};
```

**C++ 类内可以定义引用数据成员**吗？

1. 不能用默认构造函数初始化，必须提供构造函数初始化引用成员变量。否则会造成引用未初始化错误。
2. 构造函数的形参也必须是引用类型。
3. 不能在构造函数里初始化，必须在初始化列表中进行初始化。

构造函数中的能不能调用虚方法?

不要在构造函数中调用虚方法，从语法上讲，调用完全没有问题，但是从效果上看，往往不能达到需要的目的。派生类对象构造期间进入基类的构造函数时，对象类型变成了基类类型，而不是派生类类型。同样，进入基类**析构函数**时，对象也是基类类型。

所以，虚函数始终仅仅调用基类的虚函数（如果是基类调用虚函数），不能达到多态的效果，所以放在构造函数中是没有意义的，而且往往不能达到本来想要的效果。


**拷贝构造函数参数中为什么有时候要加const：** 当参数为一个临时对象的时候，临时对象是一个右值。而拷贝构造函数的参数中，如果不加const，那么就是一个非常量左值引用（非常量左值是不能引用右值的），加了const之后就是一个常量左值引用，可以引用右值。

常量左值引用是一个“万能”的引用类型，可以接受左值，右值，常量左值、常量右值。需要注意的是普通的左值引用是不能接受右值的。

**为什么用成员初始化列表会快一些**：

用户自定义类型如果使用类初始化列表，直接调用该成员变量对应的构造函数即完成初始化；如果在构造函数中初始化，因为 C++ 规定，对象的成员变量的初始化动作发生在进入构造函数本体之前，那么在执行构造函数的函数体之前首先调用默认的构造函数为成员变量设初值，在进入函数体之后，调用该成员变量对应的构造函数。因此，使用列表初始化会减少调用默认的构造函数的过程，效率高。

**限制一个类对象只能在堆上分配空间：**

(1)将类的构造函数设为私有(private)

```cpp
class MyClass {
private:
    MyClass() {} // 将构造函数设为私有
	~MyClass() {}

public:
    static MyClass* createObject() { // 静态函数，用于创建对象
        return new MyClass(); // 在函数内部创建对象并返回指针
    }
	void deleteObject() { // 静态函数，用于创建对象
        delete this;
    }
};

```

(2)将析构函数设置为私有。原因：静态对象建立在栈上，是由编译器分配和释放内存空间，编译器为对象分配内存空间时，会对类的非静态函数进行检查，即编译器会检查析构函数的访问性。当析构函数设为私有时，编译器创建的对象就无法通过访问析构函数来释放对象的内存空间，因此，编译器不会在栈上为对象分配内存。

```cpp
class MyClass {
public:
    MyClass() {} // 将构造函数设为私有

	void deleteObject() {
        delete this;
    }
private:
	~MyClass() {}
};
```

**限制一个类对象只能在栈上分配空间：**

```cpp
class MyClass {
private:
	void *operator new(size_t t) {} // 注意函数的第一个参数和返回值都是固定的
	void operator delete(void *ptr) {} // 重载了 new 就需要重载 delete
public:
	MyClass() {}
	~MyClass() {}
};
```

**禁止一个类被实例化**

- 类中定义一个纯虚函数
- 构造函数声明设置为 private 或者 delete

#### 3.2.2 拷贝构造函数

**拷贝构造函数**：创建一个新的对象，此对象是另外一个对象的拷贝品。

如果类的设计者不提供拷贝构造函数，编译器会自动生成一个，将源对象所有数据成员的值逐一赋值给目标对象相应的数据成员。**遇到指针拷贝构造，会让两个对象指向同一个地址**。

```cpp
// 必须是引用
Person(Person &);
Person(const Person &);
// 拷贝构造函数可以有多于一个的参数，但是第一个以后的所有参数都必须有默认值。
Person(const Person &p, bool maried=flase);
```

拷贝构造函数的参数是什么传递方式

1. 拷贝构造函数的参数必须使用引用传递
2. 如果拷贝构造函数中的参数不是一个引用，即形如CClass(const CClass c_class)，那么就相当于采用了传值的方式(pass-by-value)，而传值的方式会调用该类的拷贝构造函数，从而造成无穷递归地调用拷贝构造函数。因此拷贝构造函数的参数必须是一个引用。
3. 使用指针的方式CClass(const CClass *c_class)，这实际上是一个参数为CClass指针类型的构造函数

如何避免拷贝：

1. 定义一个基类，将其中的拷贝构造函数和赋值构造函数声明为私有 private；派生类以私有 private 的方式继承基类
2. C++ 11 可以使用弃置函数delete关键字

```cpp
class A {
private:
    A(const A &a); //只有声明
    A& operator=(const A &rhs);
};
// 一般而言，member 函数和 friend 函数还是有可能调用它们，这会导致一个链接错误

class Uncopyable {
private:
  Uncopyable(const Uncopyable&);
  Uncopyable& operator=(const Uncopyable&);
};
class B : private Uncopyable {};
```

创建一个子类的拷贝时，C++ 要求能够访问基类的拷贝构造函数以便复制基类部分的成员。私有继承的原因是防止Uncopyable *p = new B(); 在delete p时的内存泄露。

#### 3.2.3 转型构造函数

用于类型间的转换，只有一个参数。

C++提供的关键字explicit可以用来关闭系统的隐式类型转换功能。

#### 3.2.4 移动构造函数

当临时对象在被复制后，就不再被利用了。我们完全可以把临时对象的资源直接移动，这样就避免了多余的复制构造。

```cpp
class_name(class_name && class_): ptr(class_.ptr){
    class_.ptr = nullptr;
}

class_name temp;
class_name a(std::move(temp));
```

### 3.3 指向对象的指针

要通过**指针**来访问类成员，必须使用指针操作符->。在访问一个对象的成员时：成员选择操作符“.“专门用于**对象和对象引用**，指针操作符“->”专用于**对象指针**。

```cpp
class C {
public:
    void m(){};
    void func(C *p){ p->m(); }
}
```

在成员函数内部可以用指针常量this来访问与成员函数的调用相关联的对象( this是一个关键字，this的值是 &c1，例如this.m())

### 3.4 继承

基类的所有私有成员仅在基类中可见，而在派生类中是不可见的，但派生类对象会为基类中的所有私有成员分配空间。

改变访问限制：

```cpp
class A {
public:
    void set_x(int a){};
peivate:
    int x;
}
class B {
private:
    using A::set_x;
}
```

派生类是不能继承基类的构造函数和析构函数的。定义简单派生类构造函数的一般形式为：

```
<派生类构造函数名>(<总参数列表>)：<基类构造函数名>(<参数表>) {
	<派生类新增数据成员初始化>

}；
```

在建立一个对象时，执行构造函数的顺序（先父母，再客人，后自己）是:

- 最先调用基类的构造函数，对基类数据成员初始化；对基类的构造函数的调用顺序**取决于这些基类在被继承时的说明顺序**，与它们在初始化列表中给出的顺序无关。
- 再调用数据成员是类对象的构造函数，其调用次序按在类中定义的先后次序。
- 最后执行派生类构造函数的函数体，对派生类新增数据成员初始化。

**如果基类拥有构造函数但没有默认构造函数那么派生类的构造函数必须显式地调用基类的某个构造函数**。

在多条继承路径上有一个公共的基类时，如果希望只存储一个公共基类，可利用虚基类机制。

```cpp
class B { public: int b; };
class B1:virtual public B { private: int b1; };
class B2:virtual public B { private: int b2; };
class C:public B1, public B2 {private: int C; };
```

C++规定，在一个成员初始化列表中出现对虚基类和非虚基类构造函数的调用，则虚基类的构造函数先于非虚基类的构造函数的执行。

**赋值兼容规则**是指:在公有派生的情况下，一个派生类的对象可用于基类对象适用的地方。赋值兼容规则有三种情况：

- 派生类的对象可以赋值给基类的对象。
- 派生类的对象可以初始化基类的引用。
- 派生类的对象的地址可以赋给指向基类的指针。

**虚函数**（Virtual Function）是通过一张虚函数表（Virtual Table）来实现的。简称为V-Table。

如果父类的虚函数没有被子类改写， 那么子类的虚函数表中的元素就是父类的对应的虚函数指针；相反，如果子类改写了父类的虚函数，那么对应的虚函数表中的元素就是自己的虚函数指针，决议这个指向的过程发生在运行时，就是所谓的动态绑定！

虚指针指向的就是虚函数表，本质是一个数组，存着所有的虚函数指针。根据虚函数声明顺序，通过虚函数指针+偏移量的方式进行下标索引寻址；虚函数表保存在只读数据段（常量区）

纯虚函数在类的vftable表中对应的表项被赋值为0。也就是指向一个不存在的函数。

命名冲突：由于多继承，可能造成对基类中某个成员的访问出现了不唯一的情况，称为对基类成员访问的二义性问题。

```cpp
// 使用基类名字
Student s;
s.People::getname();
```

有没有其他方法判断是父类还是子类的对象？

方法1： 采用 typeid()函数进行判断（缺点：当存在继承，并且子类指针赋值给父类指针时，此时判断的对象类型为父类型，而不是子类类型）

方法2：dynamic_cast操作符可以在运行期检测某个转型动作

方法3：最好的方法是虚函数定义返回类类型

禁止继承：

解决方法一：借助 final 关键字，用该关键字修饰的类不能被继承。

解决方法二：借助友元、虚继承和私有构造函数来实现

```cpp
template <typename T>
class Base{
    friend T;
private:
    Base(){}
    ~Base(){}
};

class B:virtual public Base<B> {   //一定注意 必须是虚继承
public:
    B(){}
};
```

采用虚继承的原因是，直接由最低层次的派生类构造函数初始化虚基类。这是因为在菱形继承中，可能会存在对虚基类的多次初始化问题，为了避免出现该问题，在采用虚继承的时候，直接由最低层次的派生类构造函数直接负责虚基类类的构造。如果不加virtual的话，在构造函数的顺序中，每个类只负责自己的直接基类的初始化，所以还是可以生成对象的。加上了virtual之后，最低层次的派生类直接负责Base类的构造，但是Base类的构造函数和析构函数都是private，最低层次的派生类无法访问，所以不能生成对象。

### 3.5 多态

编译时的多态性是通过函数的重载或运算符的重载来实现的；函数模板的使用（通过将类型作为参数，传递给模板，可使编译器生成该类型的函数）。

运行时的多态性是指在程序执行前，根据函数名和参数无法确定应该调用哪一个函数，必须在程序执行过程中，根据具体执行情况来动态地确定。又叫运行期绑定

虚函数：在基类中用关键字virtual修饰的成员函数称为虚成员函数，虚函数的定义格式为:

```cpp
virtual <类名> <函数名> (参数){
	函数体
};
```

C++中，只有满足某些特定条件的成员函数才可能是多态的。

- 必须存在一个继承体系结构。
- 继承体系结构中的一-些类必须具有同名的虚成员函数。
- 至少有一个基类类型的指针或基类类型的引用。这个指针或引用可用来对虚成员函数进行调用。

当声明了基类的一个成员函数为虚函数后，即使该成员函数没有在派生类中被显式地声明为虚函数，但它在所有派生类中也将自动成为虚函数。

```cpp
class Person {
public:
    virtual void hello();
    virtual void hello2();
}

class Student: public Person {
public:
    void hello();
}
// 成员函数Person::hello()和Student::hello()的入口地址不同，覆盖
// 成员函数Person::hello2()和Student::hello2()的入口地址相同
```

**为什么构造函数不可以是虚函数？**

1. 虚析构：将**可能会被继承**的父类的析构函数设置为虚函数，可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。如果基类的析构函数不是虚函数，在特定情况下会导致派生来无法被析构。C++默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。
   1. 用派生类类型指针绑定派生类实例，析构的时候，不管基类析构函数是不是虚函数，都会正常析构
   2. **用基类类型指针绑定派生类实例**，析构的时候，如果基类析构函数不是虚函数，则只会析构基类，不会析构派生类对象，从而造成内存泄漏。为什么会出现这种现象呢，个人认为析构的时候如果没有虚函数的动态绑定功能，就只根据指针的类型来进行的，而不是根据指针绑定的对象来进行，所以只是调用了基类的析构函数；如果基类的析构函数是虚函数，则**析构的时候就要根据指针绑定的对象来调用对应的析构函数了。**
2. 不能虚构造：
   1. 从存储空间角度：虚函数对应一个vtale,这个表的地址是存储在对象的内存空间的。如果将构造函数设置为虚函数，就需要到vtable 中调用，可是对象还没有实例化，没有内存空间分配，如何调用。（悖论）
   2. 从使用角度：虚函数主要用于在信息不全的情况下，能使重载的函数得到对应的调用。构造函数本身就是要初始化实例，那使用虚函数也没有实际意义。所以构造函数没有必要是虚函数。虚函数的作用在于通过父类的指针或者引用来调用它的时候能够变成调用子类的那个成员函数。而构造函数是在创建对象时自动调用的，不可能通过父类的指针或者引用去调用，因此也就规定构造函数不能是虚函数。
   3. 从实现上看，vbtl 在构造函数调用后才建立，因而构造函数不可能成为虚函数。从实际含义上看，在调用构造函数时还不能确定对象的真实类型（因为子类会调父类的构造函数）；而且构造函数的作用是提供初始化，在对象生命期只执行一次，不是对象的动态行为，也没有太大的必要成为虚函数。

**虚函数可以内联吗？**

虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。

理由如下：内联是在发生在编译期间，编译器会自主选择内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。 inline virtual唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如 Base::who()），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。

**虚函数可以是模板函数吗？**

模板类可以使用虚函数，模板函数不能是虚函数。编译器期望在处理类定义的时候就能确定虚函数表的大小，如果允许有类的虚成员模板函数，那么就必须要求编译器提前知道程序中有对该类的该虚成员模板函数的调用，而这时不可行的。

### 3.5 覆盖（重写）

其函数名，参数列表，返回值类型，所有都必须同基类中被重写的函数一致。只有函数体不同（花括号内），派生类对象调用时会调用派生类的重写函数，不会调用被重写函数。重写的基类中被重写的函数必须有virtual修饰。

```cpp
class A {
public:
    virtual void fun(){
        cout << "A";
    }
};
class B :public A {
public:
    virtual void fun(){
        cout << "B";
    }
};
A* a = new B();
a->fun();  //输出B，A类中的fun在B类中重写
```

### 3.6 重载、遮蔽

函数重载是指同一可访问区内被声明的几个具有不同参数列（参数的类型，个数，顺序不同）的同名函数

```cpp
class A {
    void fun() {};
    void fun(int i) {};
    void fun(int i, int j) {};
};
```

C++函数重载底层实现原理是C++利用**命名倾轧**技术，来改名函数名，区分参数不同的同名函数。

遮蔽：函数名相同，函数签名可相同可不相同，且编译期绑定

### 3.7 抽象基类

如果一个类中至少有一个纯虚函数，那么这个类被成为抽象类(abstract class)。

```cpp
class Person {
public:
    // 纯虚函数
    virtual void age()=0;
}
```

由于纯虚函数无函数体，所以在派生类中没有重新定义纯虚函数之前，是不能调用这种函数的。

将函数名赋值为0的含义是，将指向函数体的指针值赋初值0。

抽象基类不能被实例化

注：
- 虽不能声明抽象类的实例，也不能用抽象类作为参数类型，函数返回类型或显示转换类型，但可以声明抽象类的指针或引用，当用这种基类指针指向其派生类的对象时，必须在派生类中重载纯虚函数，否则会产生程序的运行错误。.
- 从抽象类派生出的新类，**必须重新定义其父类的每一个纯虚函数或者把这些函数继续声明为纯虚函数**。

### 3.8 运行期类型识别

 c语言强制类型转换主要用于基础的数据类型间的转换，语法为：

```cpp
(type-id)expression//转换格式1
type-id(expression)//转换格式2
```

c++除了能使用c语言的强制类型转换外，还新增了四种强制类型转换：**static_cast、dynamic_cast、const_cast、reinterpret_cast**
**static_cast**相当于传统的C语言里的强制转换，该运算符把expression转换为new_type类型，用来强迫隐式转换，例如non-const对象转为const对象，编译时检查，用于非多态的转换，可以转换指针及其他，但没有运行时类型检查来保证转换的安全性。

①用于类层次结构中基类（父类）和派生类（子类）之间指针或引用的转换（向上转型）。

②用于基本数据类型之间的转换，如把int转换成char，把int转换成enum。

③把空指针转换成目标类型的空指针。

```cpp
char a = 'a';
int b = static_cast<char>(a);//正确，将char型数据转换成int型数据

double *c = new double;
void *d = static_cast<void*>(c);//正确，将double指针转换成void指针

int e = 10;
const int f = static_cast<const int>(e);//正确，将int型数据转换成const int型数据

const int g = 20;
int *h = static_cast<int*>(&g);//编译错误，static_cast不能转换掉g的const属性
```

**dynamic_cast**操作符可以在**运行期检测**某个转型动作是否安全。dynamic_cast仅**对多态类型有效**。dynamic_cast操作正确的前提是转型的源(基)类型必须有虚函数，但与转型的目标类型是否有虚函数无关。

dynamic_cast运行时的类型判断和转换，C++的dynamic_cast会比较虚函数表，也就是一层一层匹配v-table，开销巨大

在<>中指定的dynamic_ cast的**目的类型必须是一个指针或引用**。

```cpp
class B{
public:
	virtual void f() {cout<<"f()"<<endl;} 
};
class D:public B{
public:
	void m() {cout<<"m()"<<endl;} 
};

int main(){
	D *p=dynamic_cast<D*>(new B); 
    //能够判断转型是否安全，如果安全，则返回B对象的地址，否则返回NULL。 本例返回NULL。
}
```

1. 子类转换为父类：向上转型，使用dynamic_cast(expression)，这种转换相对来说比较安全不会有数据的丢失；
2. 父类转换为子类：向下转型，可以使用强制转换，这种转换时不安全的，会导致数据的丢失，原因是父类的指针或者引用的内存中可能不包含子类的成员的内存。

**const_cast**用于修改类型的const或volatile属性。（volatile提醒编译器它后面所定义的变量随时都有可能改变，因此编译后的程序每次需要存储或读取这个变量的时候，告诉编译器对该变量不做优化，都会直接从变量内存地址中读取数据）

**reintepret_cast**它可以把一个指针转换成一个整数，也可以把一个整数转换成一个指针（先把一个指针转换成一个整数，再把该整数转换成原类型的指针，还可以得到原先的指针值）。new_type必须是一个指针、引用、算术类型、函数指针或者成员指针。

```cpp
#include <iostream>
using namespace std;
int output(int p){
    cout << p <<endl;　　return 0;
}

typedef int (*test_func)(int );//定义函数指针test_func
int main(){
    int p = 10;
    test_func fun1 = output;
    fun1(p);//正确
    test_func fun2 = reinterpret_cast<test_func>(&p);
    fun2(p);//...处有未经处理的异常: 0xC0000005: Access violation
    return 0;
}
```

### 3.9 友元函数

友元的目的就是让一个函数或者类 访问另一个类中的私有成员，三种实现：

- 全局函数做友元
- 类做友元
- 成员函数做友元

## 4 STL容器

### 4.1 标准模板库STL

标准模板库STL组成部分：

1. 容器(Container)是一种数据结构， 如list, vector, 和deques，以模板类的方法提供。为了访问容器中的数据，可以使用由容器类输出的迭代器。
2. 算法（Algorithm）是用来操作容器中的数据的模板函数。例如，STL用sort()来对一 个vector中的数据进行排序，用find()来搜索一个list中的对象， 函数本身与他们操作的数据的结构和类型无关，因此他们可以用于从简单数组到高度复杂容器的任何数据结构上。
3. 迭代器（Iterator）提供了访问容器中对象的方法。例如，可以使用一对迭代器指定list或vector中的一定范围的对象。 迭代器就如同一个指针。事实上，C++ 的指针也是一种迭代器。 但是，迭代器也可以是那些定义了operator*()以及其他类似于指针的操作符方法的类对象;
4. 仿函数（Function object）仿函数又称之为函数对象， 其实就是重载了操作符的struct,没有什么特别的地方。
5. 适配器（Adaptor）简单的说就是一种接口类，专门用来修改现有类的接口，提供一中新的接口；或调用现有的函数来实现所需要的功能（例如stack）。主要包括3中适配器Container Adaptor、Iterator Adaptor、Function Adaptor。
6. 空间配制器（Allocator）为STL提供空间配置的系统。其中主要工作包括两部分：（1）对象的创建与销毁；（2）内存的获取与释放。

### 4.2 常见的容器

1. **顺序容器**容器并非排序的，元素的插入位置同元素的值无关。包含vector、deque、list，具体实现原理如下：
   1. vector 动态数组。元素在内存连续存放。随机存取任何元素都能在常数时间完成。在尾端增删元素具有较佳的性能。
   2. deque 双向队列。元素在内存连续存放。随机存取任何元素都能在常数时间完成（仅次于vector）。在两端增删元素具有较佳的性能（大部分情况下是常数时间）。
   3. list 双向链表。元素在内存不连续存放。在任何位置增删元素都能在常数时间完成。不支持随机存取。
2. **关联式容器**元素是排序的；插入任何元素，都按相应的排序规则来确定其位置；在查找时具有非常好的性能；通常以平衡二叉树的方式实现。包含set、multiset、map、multimap，具体实现原理如下：	
   1. set/multiset 即集合。set中不允许相同元素，multiset中允许存在相同元素。
   2. map/multimap map与set的不同在于map中存放的元素有且仅有两个成员变，一个名为first,另一个名为second, map根据first值对元素从小到大排序，并可快速地根据first来检索元素。

3. **容器适配器封装了一些基本的容器**，使之具备了新的函数功能，比如把**deque**封装一下变为一个具有stack功能的数据结构。这新得到的数据结构就叫适配器。包含stack,queue,priority_queue，具体实现原理如下 **(deque的特点是队首和队尾的增删效率高，所以采用deque的数据结构)**：

   1. stack 栈是项的有限序列，并满足序列中被删除、检索和修改的项只能是最进插入序列的项（栈顶的项）。后进先出。
   2. queue 队列。插入只可以在尾部进行，删除、检索和修改只允许从头部进行。先进先出。
   3. priority_queue 优先级队列。内部维持某种有序，然后确保优先级最高的元素总是位于头部。最高优先级元素总是第一个出列。

map内部实现了一个**红黑树**（红黑树是非严格平衡的二叉搜索树，而AVL是严格平衡二叉搜索树），对于map进行的查找、删除、添加等一系列的操作都相当于是对红黑树进行的操作。红黑树有自动排序的功能，因此map内部所有元素都是有序的，红黑树的每一个节点都代表着map的一个元素。左子树上所有节点的键值都小于根节点的键值，右子树所有节点的键值都大于根节点的键值。使用中序遍历可将键值按照从小到大遍历出来。

unordered_map内部实现了一个**哈希表**（也叫散列表），底层使用hashtable+buket的实现原理，通过把关键码值映射到Hash表中一个位置来访问记录，查找时间复杂度可达O（1），元素的排列顺序是无序的。处理hash冲突的方法就是在相同hash值的元素位置下面挂buket（桶），当数据量在8以内使用链表来实现桶，当数据量大于8 则自动转换为红黑树结构 也就是有序map的实现结构。

解决Hash冲突：开放定址法（线性地址）、再哈希、链地址

deque内部实现的是一个**双向队列**。元素在内存连续存放。随机存取任何元素都在常数时间完成（仅次于vector）。所有适用于vector的操作都适用于deque。在两端增删元素具有较佳的性能（大部分情况下是常数时间）。

list内部实现的是一个**双向链表**。元素在内存不连续存放。在任何位置增删元素都能在常数时间完成。不支持随机存取。无成员函数，给定一个下标i，访问第i个元素的内容，只能从头部挨个遍历到第i个元素。

哈希表中元素的数量超过了其容量的一定比例（称为负载因子），就会触发扩容操作。

1. 选择新的更大的存储空间。通常，这个新的空间大小是原来空间大小的两倍。
2. 对所有已经存在的键值对进行重新哈希。
3. 将每个键值对放到新的哈希值对应的存储位置。

**在扩容操作期间，哈希表的元素可能会被重新分配到新的桶中，这可能会导致遍历哈希表时的顺序发生变化。因此，在进行扩容操作时，应该避免遍历哈希表并且保持对哈希表的引用不变。**

vector的线程安全问题：是不安全的。

- 用迭代器访问数组元素时，某个线程的 push_back操作导致数组重新分配内存，那么就会导致迭代器失效
- 下标访问时，更不用说了，同时的写操作，或者写读等操作也可能出现脏数据

解决办法：

- 知道数据量的时候可以 reserve 一下，预先分配足够的内存。 再就是对迭代器的使用要小心，迭代器要时刻更新。
- 对于②简单的加个锁

红黑树性质：

1. 每个节点非红即黑
2. 根节点是黑的;
3. 每个叶节点（叶节点即树尾端NULL指针或NULL节点）都是黑的;
4. 如果一个节点是红色的，则它的子节点必须是黑色的。
5. 对于任意节点而言，其到叶子点树NULL指针的每条路径都包含相同数目的黑节点;

红黑树不是高度平衡的，算是一种折中，插入最多两次旋转，删除最多三次旋转。所以红黑树在查找，插入删除的性能都是O(logn)，性能稳定。

### 4.3 算法
capacity：该值在容器初始化时赋值，指的是容器能够容纳的最大的元素的个数。还不能通过下标等访问，因为此时容器中还没有创建任何对象。size：指的是此时容器中实际的元素个数。可以通过下标访问0-(size-1)范围内的对象。

resize和reserve区别主要有以下几点：

1. resize既分配了空间，也创建了对象；reserve表示容器预留空间，但并不是真正的创建对象，需要通过insert（）或push_back（）等创建对象。
2. resize既修改capacity大小，也修改size大小；reserve只修改capacity大小，不修改size大小。
3. 两者的形参个数不一样。 resize带两个参数，一个表示容器大小，一个表示初始值（默认为0）；reserve只带一个参数，表示容器预留的大小。

如何避免vector频繁扩容？

假定你想建立一个容纳1-1000值的vector<int>。没有使用reserve，你可以像这样来做：`vector<int> v; for (int i = 1; i <= 1000; ++i) v.push_back(i);`在大多数STL实现中，这段代码在循环过程中将会导致2到10次重新分配。

把代码改为使用reserve()可以避免频繁扩容。

如果要将一个临时变量push到容器的末尾，push_back()需要先构造临时对象，再将这个对象拷贝到容器的末尾，而emplace_back()则直接在容器的末尾构造对象，这样就省去了拷贝的过程。

### 4.4 迭代器

迭代器失效：

- 对于序列容器vector，deque来说，使用erase后，后边的每个元素的迭代器都会失效，后边每个元素都往前移动一位，erase返回下一个有效的迭代器。
- 对于关联容器map，set来说，使用了erase后，当前元素的迭代器失效，但是其结构是红黑树，删除当前元素，不会影响下一个元素的迭代器，所以在调用erase之前，记录下一个元素的迭代器即可。
- 对于list来说，它使用了不连续分配的内存，并且它的erase方法也会返回下一个有效的迭代器，因此上面两种方法都可以使用。

迭代器不是指针，是类模板。他只是模拟了指针的一些功能，重载了指针的一些操作符->、++、--等。他把不同集合类的访问逻辑抽象出来，使得不用暴露集合内部的结构而达到循环遍历集合的效果。

### 4.5 空间配制器

两种C++类对象实例化方式的异同在c++中，创建类对象一般分为两种方式：一种是直接利用构造函数,直接构造类对象，如 Test test()；另一种是通过new来实例化一个类对象，如 Test *pTest = new Test；那么，这两种方式有什么异同点呢？内存分配主要有三种方式：（1） 静态存储区分配（2） 栈空间分配（3）堆空间分配

C++ STL空间配置器实现很容易想象，为了实现空间配置器，完全可以利用new和delete函数并对其进行封装实现STL的空间配置器，的确可以这样。但是，为了最大化提升效率，SGI STL版本并没有简单的这样做，而是采取了一定的措施，实现了更加高效复杂的空间分配策略。由于以上的构造都分为两部分，所以，在SGI STL中，**将对象的构造切分开来，分成空间配置和对象构造两部分。**

内存配置操作: 通过alloc::allocate()实现

内存释放操作: 通过alloc::deallocate()实现

对象构造操作: 通过::construct()实现

对象释放操作: 通过::destroy()实现

关于**内存空间的配置与释放**，SGI STL采用了两级配置器：

- 第一级，当配置区块大于128bytes时，调用第一级配置器，直接使用malloc()、free()进行内存的分配和释放，使用类似new_handler机制解决内存不足（**抛出异常**）
- 第二级，当配置区块小于128bytes时，采用内存池的整理方式。内存池以malloc配置而得，如果内存不足转第一级配置器处理。

## 5 C++新特性

### 5.1 统一的初始化方法

C++98/03 可以使用初始化列表（initializer list）进行初始化：

```cpp
int i_arr[3] = { 1, 2, 3 };
long l_arr[] = { 1, 3, 2, 4 };
struct A
{
    int x;
    int y;
} a = { 1, 2 };
```

 **但是**这种初始化方式的**适用性非常狭窄**，只有上面提到的这两种数据类型可以使用初始化列表。在 C++11 中，初始化列表的适用性被大大增加了。它现在可以用于任何类型对象的初始化，实例如下：

```cpp
class Foo{
public:
    Foo(int) {}
private:
    Foo(const Foo &);
};
int main(void)
{
    Foo a1(123);
    Foo a2 = 123;  //error: 'Foo::Foo(const Foo &)' is private。123被转化为Foo对象
    Foo a3 = { 123 };
    Foo a4 { 123 };
    int a5 = { 3 };
    int a6 { 3 };
}
```

a3、a4 使用了新的初始化方式来初始化对象，效果如同 a1 的直接初始化。a5、a6 则是基本数据类型的列表初始化方式。可以看到，它们的形式都是统一的。这里需要注意的是，a3 虽然使用了等于号，但它仍然是列表初始化，因此，私有的拷贝构造并不会影响到它。a4 和 a6 的写法，是 C++98/03 所不具备的。在 C++11 中，可以直接在变量名后面跟上初始化列表，来进行对象的初始化。

### 5.2 成员变量默认初始化

构建一个类的对象不需要用构造函数初始化成员变量。

```cpp
#include<iostream>
using namespace std;
class B{
public:
    int m = 1234; //成员变量有一个初始值
    int n;
};
int main()
{
    B b;
    cout << b.m << endl;
    return 0;
}
```

### 5.3 auto关键字

 用于定义变量，编译器可以自动判断的类型（前提：定义一个变量时对其进行初始化）。

```cpp
vector< vector<int> > v;
vector< vector<int> >::iterator i = v.begin();
```

 可以看出来，定义迭代器 i 的时候，类型书写比较冗长，容易出错。然而有了 auto 类型推导，我们大可不必这样，只写一个 auto 即可。

### 5.4 decltype 求表达式的类型

因为 auto 并不适用于所有的自动类型推导场景，在某些特殊情况下 auto 用起来非常不方便，甚至压根无法使用，所以 decltype 关键字也被引入到 C++11 中。auto 和 decltype 关键字都可以自动推导出变量的类型，但它们的用法是有区别的：

```cpp
auto varname = value;
decltype(exp) varname = value;
```

其中，varname 表示变量名，value 表示赋给变量的值，exp 表示一个表达式。

auto 根据"="右边的初始值 value 推导出变量的类型，而 decltype 根据 exp 表达式推导出变量的类型，跟"="右边的 value 没有关系。

另外，auto 要求变量必须初始化，而 decltype 不要求。这很容易理解，auto 是根据变量的初始值来推导出变量类型的，如果不初始化，变量的类型也就无法推导了。

### 5.5 智能指针

auto_ptr（C++98的方案，C++11已经弃用），采用所有权模式。p2剥夺了p1的所有权，但是当程序运行时访问p1将会报错。所以auto_ptr的缺点是：存在潜在的内存崩溃问题。

```cpp
auto_ptr<string> p1(new string("I reigned loney as a cloud."));
auto_ptr<string> p2;
p2=p1; //auto_ptr不会报错
```

 C++引用了智能指针auto_ptr，以帮助自动完成这个过程。随后的编程体验（尤其是使用STL）表明，需要有更精致的机制。基于程序员的编程体验和BOOST库提供的解决方案，C++11摒弃了auto_ptr，并新增了三种智能指针：unique_ptr、shared_ptr和weak_ptr。所有新增的智能指针都能与STL容器和移动语义协同工作。

 C语言规定所有变量在使用前必须先定义，指定其类型，并按此分配内存单元。指针变量不同于整型变量和其他类型的变量，它是专门用来存放地址的，所以必须将它定义为“指针类型”。

 **智能指针和普通指针的区别**在于智能指针实际上是对普通指针加了一层封装机制，区别是它负责自动释放所指的对象，这样的一层封装机制的目的是为了使得智能指针可以方便的管理一个对象的生命期。

unique_ptr（替换auto_ptr），unique_ptr实现独占式拥有或严格拥有概念，保证同一时间内只有一个智能指针可以指向该对象。因此，unique_ptr比auto_ptr更安全。 另外unique_ptr还有更聪明的地方：当程序试图将一个 unique_ptr 赋值给另一个时，如果源unique_ptr 是个临时右值，编译器允许这么做；如果源 unique_ptr 将存在一段时间，编译器将禁止这么做

```cpp
unique_ptr<string> pu1(new string ("hello world"));
unique_ptr<string> pu2;
pu2 = pu1;                                      // #1 not allowed
unique_ptr<string> pu3;
pu3 = unique_ptr<string>(new string ("You"));   // #2 allowed
```

 weak_ptr是一种不控制对象生命周期的智能指针, weak_ptr设计的目的是为配合shared_ptr而引入的一种智能指针来协助shared_ptr工作，它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的构造和析构不会引起引用记数的增加或减少。weak_ptr是用来解决shared_ptr相互引用时的死锁问题，如果说两个shared_ptr相互引用，那么这两个指针的引用计数永远不可能下降为0，资源永远不会释放。它是对对象的一种弱引用，不会增加对象的引用计数，和shared_ptr之间可以相互转化，shared_ptr可以直接赋值给它，它可以通过调用lock函数来获得shared_ptr。
```cpp
class B;
class A{
public:
    shared_ptr<B> pb_;
    ~A(){ cout<<"A delete\n";}
};
class B{
public:
    shared_ptr<A> pa_;
    ~B(){ cout<<"B delete\n";}
};

void fun(){
    shared_ptr<B> pb(new B());
    shared_ptr<A> pa(new A());
    pb->pa_ = pa;
    pa->pb_ = pb;
    cout<<pb.use_count()<<endl;
    cout<<pa.use_count()<<endl;
}
```

可以看到fun函数中pa ，pb之间互相引用，两个资源的引用计数为2，当要跳出函数时，智能指针pa，pb析构时两个资源引用计数会减一，但是两者引用计数还是为1，导致跳出函数时资源没有被释放（A B的析构函数没有被调用），如果把其中一个改为weak_ptr就可以了，我们把类A里面的shared_ptr pb_改为weak_ptr pb; 这样的话，资源B的引用开始就只有1，当pb析构时，B的计数变为0，B得到释放，B释放的同时也会使A的计数减一，同时pa析构时使A的计数减一，那么A的计数为0，A得到释放。

**注意：** 我们不能通过weak_ptr直接访问对象的方法，比如B对象中有一个方法print(),我们不能这样访问，pa->pb_->print()；pb_是一个weak_ptr，应该先把它转化为shared_ptr，如：shared_ptr p = pa->pb_.lock(); p->print();

和 unique_ptr、weak_ptr 不同之处在于，多个 shared_ptr 智能指针可以**共同使用同一块堆内存**。并且，由于该类型智能指针在实现上采用的是引用计数机制，即便有一个 shared_ptr 指针放弃了堆内存的“使用权”（引用计数减 1），也不会影响其他指向同一堆内存的 shared_ptr 指针（只有引用计数为 0 时，堆内存才会被自动释放）。[智能指针shared_ptr踩坑笔记](https://zhuanlan.zhihu.com/p/291770399)

shared_ptr 本身不是100% 线程安全的。它的引用计数本身是安全且无锁的，但对象的读写则不是，因为shared_ptr 有两个数据成员，读写操作不能原子化。即：

- 一个shared_ptr 对象实体可被多个线程同时读取；
- 两个shared_ptr 对象实体可以被两个线程同时写入，“析构”算写操作；

如果要从多个线程读写同一个shared_ptr 对象，那么需要加锁。

```cpp
std::shared_ptr<int> p1(new int(10));
std::shared_ptr<int> p2(p1);

p1.reset();//引用计数减 1,p1为空指针

//以上操作，并不会影响 p2
*p2 = 10;
//判断当前和 p2 同指向的智能指针有多少个
p2.use_count() = 1;
```

**make_unique/make_shared**

被用来构造一个类型为 T 的对象，并将其封装在 std::unique_ptr/std::shared_ptr中

1. 它们提供了异常安全性。直接使用 new 可能会导致资源泄漏，如果在到达 delete 语句之前代码抛出了异常，因为 new 和 delete 是分开的语句。make_unique 和 make_shared 通过使用 RAII（Resource Acquisition Is Initialization，资源获取即初始化）来处理这个问题。
2. 减少代码冗余，不需要写 new 关键字。
3. make_shared 的性能更好：它对控制块和管理的对象进行一次动态内存分配，而使用 new 单独为 shared_ptr 分配内存则需要进行两次分配。

```cpp
// 在堆上创建了一个新的整数，然后 std::shared_ptr 构造函数分配一个新的控制块来跟踪该对象
auto ptr = std::shared_ptr<int>(new int(42));
auto ptr = std::make_shared<int>(42);
```

### 5.6 空指针 nullptr（原来NULL）

 nullptr 是 nullptr_t 类型的右值常量，专用于初始化空类型指针。
在C语言中，NULL被定义为 **#define NULL ((void *)0)**，在C语言中可以把void指针转换为相应类型的指针。

```cpp
int *p = NULL;
```

在C++中以上编译会出错，C++是强类型语言，void指针不能隐式转换为其他类型的指针，所以编译器将NULL宏定义为0，但是使用NULL代替0表示空指针在函数重载时会出现问题。NULL作为函数参数进行函数重载会出现优先使用重载类型为int型的函数。**nullptr 可以被隐式转换成任意的指针类型。**

```cpp
void func(void *i){
	cout << "func1" << endl;
}
void func(int i){
	cout << "func2" << endl;
}

func(NULL);		// func2
func(nullptr);	// func1
```

### 5.7 基于范围的for循环

如果要用 for 循环语句遍历一个数组或者容器，只能套用如下结构：

```cpp
char arc[] = "www.123.com";
int i;
//for循环遍历普通数组
for (i = 0; i < strlen(arc); i++) { cout << arc[i]; }
vector<char>myvector(arc,arc+3);
//for循环遍历 vector 容器
for (auto iter = myvector.begin(); iter != myvector.end(); ++iter) { cout << *iter; }
```

### 5.8 右值引用&&和move语义 

[从4行代码看右值引用 - qicosmos(江南) - 博客园](https://www.cnblogs.com/qicosmos/p/4283455.html)

C++98/03 标准中就有引用，使用 "&" 表示。但此种引用方式有一个缺陷，即**正常情况下只能操作 C++ 中的左值，无法对右值添加引用**。举个例子：

```cpp
int num = 10;
int &b = num; //正确
int &c = 10; //错误
```

如上所示，编译器允许我们为 num 左值建立一个引用，但不可以为 10 这个右值建立引用。因此，C++98/03 标准中的引用又称为左值引用。

注意，虽然 C++98/03 标准不支持为右值建立非常量左值引用，但允许使用**常量左值引用**操作右值。也就是说，常量左值引用既可以操作左值，也可以操作右值，例如：

```cpp
int num = 10;
const int &b = num;
const int &c = 10;
```

我们知道，右值往往是没有名称的，因此要使用它只能借助引用的方式。这就产生一个问题，**实际开发中我们可能需要对右值进行修改（实现移动语义时就需要），显然左值引用的方式是行不通的。**

为此，C++11 标准新引入了另一种引用方式，称为右值引用，用 "&&" 表示。

需要注意的，和声明左值引用一样，右值引用也必须立即进行初始化操作，且只能使用右值进行初始化，比如：

```cpp
int num = 10;
//int && a = num;  //右值引用不能初始化为左值
int && a = 10;
a = 100;
cout << a << endl;
/*    程序运行结果：        
        100    
*/          
```

 另外值得一提的是，C++ 语法上是支持定义常量右值引用的。 但这种定义出来的右值引用并无实际用处。一方面，右值引用主要用于移动语义和完美转发，其中前者需要有修改右值的权限；其次，常量右值引用的作用就是引用一个不可修改的右值，这项工作完全可以交给常量左值引用完成。

**move 本意为 "移动"，但该函数并不能移动任何数据，它的功能很简单，就是将某个左值强制转化为右值。**

```cpp
template <typename T>
typename remove_reference<T>::type&& move(T&& t)
{
	return static_cast<typename remove_reference<T>::type &&>(t);
}

//原始的，最通用的版本
template <typename T> struct remove_reference{
    typedef T type;  //定义 T 的类型别名为 type
};
 
//部分版本特例化，将用于左值引用和右值引用
template <class T> struct remove_reference<T&> //左值引用
{ typedef T type; }
 
template <class T> struct remove_reference<T&&> //右值引用
{ typedef T type; }   
  
//举例如下,下列定义的a、b、c三个变量都是int类型
int i;
remove_refrence<decltype(42)>::type a;             //使用原版本，
remove_refrence<decltype(i)>::type  b;             //左值引用特例版本
remove_refrence<decltype(std::move(i))>::type  b;  //右值引用特例版本 

// 举例
int var = 10; 

std::move(var) => std::move(int&& &) => 折叠后 std::move(int&)

// 此时：T 的类型为 int&，typename remove_reference<T>::type 为 int，
//这里使用 remove_reference 的左值引用的特例化版本

// 通过 static_cast 将 int& 强制转换为 int&&

// 整个std::move被实例化如下
int&& move(int& t) {
    return static_cast<int&&>(t); 
}
```

引用折叠原理

- 右值传递给上述函数的形参 T&& 依然是右值，即 T&& && 相当于 T&&。
- 左值传递给上述函数的形参 T&& 依然是左值，即 T&& & 相当于 T&。

**完美转发：**

指函数模板在向其他函数传递参数时保留该参数的左右值属性。

这样做是为了保留在其他函数针对转发而来的参数的左右值属性进行不同处理（比如参数为左值时实施拷贝语义；参数为右值时实施移动语义）的可能性。

如果将自身参数不分左右值一律转发为左值，其他函数就只能将转发而来的参数视为左值，从而失去针对该参数的左右值属性进行不同处理的可能性。

```cpp
void fun(int &x) { cout << "lvalue ref" << endl; }
void fun(int &&x) { cout << "rvalue ref" << endl; }
void fun(const int &x) { cout << "const lvalue ref" << endl; }
void fun(const int &&x) { cout << "const rvalue ref" << endl; }
 
template<typename T>
void PerfectForward(T &&t) { fun(std::forward<T>(t)); }
 
int main() {
	PerfectForward(10);           // rvalue ref
 
	int a;
	PerfectForward(a);            // lvalue ref
	PerfectForward(std::move(a)); // rvalue ref
 
	const int b = 8;
	PerfectForward(b);            // const lvalue ref
	PerfectForward(std::move(b)); // const rvalue ref
}
```

### 5.9 无序容器（哈希表）

### 5.10 Lambda匿名函数

所谓匿名函数，简单地理解就是没有名称的函数，又常被称为 lambda 函数或者 lambda 表达式。

```cpp
[外部变量访问方式说明符] (参数) mutable noexcept/throw() -> 返回值类型{
	函数体;
};
```

[外部变量方位方式说明符]：方括号用于向编译器表明当前是一个 lambda 表达式，其不能被省略。在方括号内部，可以注明当前 lambda 函数的函数体中可以使用哪些“外部变量”。 所谓外部变量，指的是和当前 lambda 表达式位于同一作用域内的所有局部变量。

(参数)：和普通函数的定义一样，lambda 匿名函数也可以接收外部传递的多个参数。和普通函数不同的是，如果不需要传递参数，可以连同 () 小括号一起省略；

mutable：此关键字可以省略，如果使用则之前的 () 小括号将不能省略（参数个数可以为 0）。默认情况下，对于以值传递方式引入的外部变量，不允许在 lambda 表达式内部修改它们的值（可以理解为这部分变量都是 const 常量）。而如果想修改它们，就必须使用 mutable 关键字。**注意:**对于以值传递方式引入的外部变量，lambda 表达式修改的是拷贝的那一份，并不会修改真正的外部变量

noexcept/throw()：可以省略，如果使用，在之前的 () 小括号将不能省略（参数个数可以为 0）。默认情况下，lambda 函数的函数体中可以抛出任何类型的异常。而标注 noexcept 关键字，则表示函数体内不会抛出任何异常；使用 throw() 可以指定 lambda 函数内部可以抛出的异常类型。

返回值类型：指明 lambda 匿名函数的返回值类型。值得一提的是，如果 lambda 函数体内只有一个 return 语句，或者该函数返回 void，则编译器可以自行推断出返回值类型，此情况下可以直接省略"-> 返回值类型"。

函数体：和普通函数一样，lambda 匿名函数包含的内部代码都放置在函数体中。该函数体内除了可以使用指定传递进来的参数之外，还可以使用指定的外部变量以及全局范围内的所有全局变量。

```cpp
int num[4] = {4, 2, 3, 1};
//对 a 数组中的元素进行排序
sort(num, num+4, [=](int x, int y) -> bool{ return x < y; } );
```