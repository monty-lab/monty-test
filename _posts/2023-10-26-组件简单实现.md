---
layout: post
title: C++简单组件实现
date: 2023-10-26 13:36 +0800
last_modified_at: 2023-10-26 13:36 +0800
tags: [C++, Vector, 智能指针]
toc:  true
---

实现了简单的C++ Vector功能以及智能指针相关。

## Vector
```c++
template <typename T>
class vector_ {
   public:
    vector_() {
        size = 0;
        capaticy = 0;
        list = nullptr;
    }

    vector_(int size, T value) {
        list = nullptr;
        list = new T[size];
        for (unsigned int i = 0; i < size; i++) {
            *(list + i) = value;
        }
        this->size = size;
        this->capaticy = size;
    }

    void push_back(T value) {
        if (capaticy == 0) {
            list = new T[20];
            *list = value;
            size = 1;
            capaticy = 20;
        } else if (size == capaticy) {
            capaticy = size * 2;
            T* new_list = new T[capaticy];
            for (unsigned int i = 0; i < size; i++) {
                *(new_list + i) = *(list + i);
            }
            delete[] list;
            list = new_list;
            *(list + size) = value;
            ++size;
        } else {
            *(list + size) = value;
            ++size;
        }
    }

    void pop_back() { --size; }

    T& operator[](unsigned int index) {
        if (index >= 0 && index < size) return *(list + index);
    }

    ~vector_() { delete[] list; }

   private:
    unsigned int size;
    unsigned int capaticy;
    T* list;
};
```
## 智能指针
```c++
#include <mutex>
#include <pthread.h>
using namespace std;

template <class T>
class weak_ptr;
template <class T>
class share_ptr {
   public:
    share_ptr(T* ptr = nullptr) : _ptr(ptr), _pcount(new int(1)), _pmutex(new mutex) {}
    share_ptr(const share_ptr<T>& sp) : _ptr(sp._ptr), _pcount(sp._pcount), _pmutex(sp._pmutex) {
        add_count();
    }

    share_ptr<T>& operator=(const share_ptr<T>& sp) {
        if (this != sp) {
            release();
            _ptr = sp._ptr;
            _pcount = sp._pcount;
            _pmutex = sp._pmutex;
            add_count();
        }
        return *this;
    }

    share_ptr<T>& operator=(const weak_ptr<T>& wp) {}

    T& operator*() { return *_ptr; }

    T* operator->() { return _ptr; }

    int use_count() { return *_pcount; }

    void add_count() {
        _pmutex->lock();
        ++(*_pcount);
        _pmutex->unlock();
    }

    ~share_ptr() { release(); }

    friend class weak_ptr<T>;

   private:
    void release() {
        bool deleteflag = false;
        _pmutex->lock();
        if (-(*_pcount) == 0) {
            delete _ptr;
            delete _pcount;
            deleteflag = true;
        }
        _pmutex->unlock();
        if (deleteflag) delete _pmutex;
    }

   private:
    int* _pcount;  // 指针方便多个share_ptr对象指向同一块地址
    T* _ptr;
    mutex* _pmutex;
};

template <class T>
class weak_ptr {
   public:
    weak_ptr(T* ptr = nullptr) : _ptr(ptr) {}
    weak_ptr(const weak_ptr<T>& wp) : _ptr(wp._ptr) {}

    weak_ptr<T>& operator=(const weak_ptr<T>& wp) {
        _ptr = wp._ptr;
        return *this;
    }

    weak_ptr<T>& operator=(const share_ptr<T>& sp) {
        _ptr = sp._ptr;
        return *this;
    }

    share_ptr<T>& lock() {
        share_ptr<T> sp(_ptr);
        return &sp;
    }

   private:
    T* _ptr;
};
```
